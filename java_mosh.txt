Java
----------











1. Compilation and Execution
=============================

A code written in java is compiled by JavaC, which comes when we install JDK. This converts the code
into ByteCode. It can be observed, Main.class along with other classes will be created as separte
files. These files are platform independent. Why? Here another component comes into play, JRE[Java 
Runtime Environment]. It has a software component called- JVM (different for each platform: linux,
MacOs, windows). This converts these classes as native code, that is understood by the machine and
hence run.
Evidence:
        
        import com.package_name;
        public class Main{                              # Main can be replaced but then Refractor!
            public static void main(String[] args){     # main() is must
                System.out.println("Hello World");
            }
        }

        $javac Main.java            # converts the .java into .class
        $ls                         # will show you the Main.java & Main.class
        $cd ../..                   # move to the source folder in Intellij
        $java com.package_name.Main # Hello world ----- is printed. 

Note: unless specified the code snippets are present in side this Main class, in the text that follows. 
Important: It is important to place code blocks inside a function or a class.

Deployment
---------------------
The way to share the executable is by using JAR(Java ARchive) file. If we go and download Super
Mario Bros Java. Since we have been using JDK(which brought with it JRE and Javacompiler) therefore
we will be able to run this. JRE makes it happen. This will run on any platform(Windows, Mac, linux)
given we have java runtime on it.  This is what makes it platform independent. So if you download it
we will save it .jar file [Mario.jar]. Way to launch the file: 
        java -jar Mario.jar
        jar -tvf Mario.jar      // lists all the table of content of the .jar
        jar -xvf Mario.jar      // xtract verbose file 
Note that all java will be of the form .class which cannnot be run. Bur we might use the functionality.

So if we wanted to deploy our java code, we will have to make a .jar file out of our java code. We need to 
create 'manifest.mf' file inorder to create the .jar.
        Main-Class: ClientProgram

This manifest file will have the main-class, the entry point.
        
        jar -cvfm myProgram.jar manifest.mf *.class     // create verbose file with manifest file
to run the .jar file
        java -jar myProgram.jar         // can be shared ,, ... this is deployable,,, 
                        // given the user has the java runtime. of the given version

        java -tvf myProgram.jar         // to extract, you may get something more than expected.

Variables:
----------
    
    int age = 30;       # Declaring var , multiple can be declared in the same line
    int herAge=age;     # assigning one var to the other
    
Types:
Primitive    :

    Type        | Byte      | Range     
    byte          1           
    short         2
    int           4 
    long          8

    float         4                                 // above this only integers
    double        8
    char          2
    boolean       1

    int x=123_2123;  // is perfectly fine initialisation. but 123_ is not. 
    long a=1233_12312342;   // assumes the number to intger => java: integer number too large
    long a=1233_12312342l;  // is perfectly fine 'L' is alos good.

    float x= 12.99          // java: incompatible types: possible lossy conversion from double to float
    float x= 12.99F     // is ok

"" ---> is string in java unlike python
'' ---> is character in java


Reference types:
---------------
        Date now = new Date();
        sout(now);

The Memory management of these reference types is very different from the primitive ones. On creation,
a memory is allocated and the values are stored there. Name of the object is just a reference to that
memory location => stores the address of that oject. So when a new reference variable is created and 
assigned to an older reference variable, the new variable just starts 'pointing' to the oject memory
location, instead of creating a whole new object. So both start pointing at the same memory location.
So when the value of one of the references is changed the change is reflected in second as well. 
[is similar to python's list, python also follows a similar memry mangment].
    Also, note that the reference variable are created by user using 'new' and removed by JRE.

Remember: reference types are copied by the references and the primitive by value.

         Point p1=new Point(2,3);
         Point p2=p1;
         System.out.println(p2);
         p2.x=99;
         System.out.println(p1);        // [99,3] 


String
--------
java.lang       // automatically imported not need to import

        String s = new String("Hello world");
        String s = "Hello world";       // shorthand because of the often use.

        s=s+"hi";                       // concatenates

some useful methods:
--------------------
    .endswith("!!")
    .startswith("A")
    .length()
    .indexOf('e')           // returns index of 'e'
    .replace(target:"!", replacement:"*")       // original string does not change
                            // strings are immutable, we cannot change them.
    .toLowerCase()
    .toUpperCase()
    .trim()                 // gets rid of white spaces before and after. 
    .substring(1)           // gives all except the first ~ python's stringg[1:]
    .substring(3,5)         // ~python's stringg[3:5]=> excludes 5th INDEX
    .charAt(3)              // character at the third index [-1] does not work here. returns a 'char'
    .indexOf(char_or_string)// returns the index of first occurence
    .indexOf(ch_or_str,strt)// search starts from the index--> 'strt'

escape sequences: String name = "Hello \"Amiay\"";      // Hello "Amiay"
                  String location = "C:\\";             // one back slash to escape the other.
                  
\t, \n                are some other. 

Arrays
----------

They are also reference types. (or are they?) if not why are they declared using new.
        
        int[] arr = new int[5];
         System.out.println(arr);       //[I@5674cd4d      <-----some random value

         System.out.println(arr[0]);    //0  // this is true for any valid index
                                        //Index 6 out of bounds for length 5
This shows that are array are reference types and initialized with 0. We cannot exceed the index limit. 

So the desired result can be achieved using:

        import java.util.Arrays;

        ...

        int[] arr = new int[5];
        sout(Arrays.toString(arr));         // string representation of the array
                                            // this toString functiion is overloaded=> can be use for 
                                            // float as well

initialisation
        
        int[] arr={1,3,4,5};
        arr.length                          // not '.length()'
        Arrays.sort(arr)                    // sorts the actual array
        int[] arr2 = new int[] {1,8,9};     // is also a valid declaration
        sout(Arrays.toString(arr2));

        int[] int_arr = new int[5];         // arr of 0's
        String str_arr = new String[5]      // arr of nulls
        boolean bool_arr = new boolean[5]   // arr of falses
        // and so on

As usual we can also declare multi-dimensional arrays

        int[][]  mul = new int[2][3]        // note the two sq. braces.
        sout(Arrays.deepToString(mul));     // notice the use of '.deepToString'

        // initialisation
        int[][] aa = {{1,2},{3,4}}          // two dim array

final
=-=====
        
        final float PI = 3.14F                // 'F' necessary(default is 'double')

Upper case is used to define the constants. Final values cannot be changed. 

Arithmetics
============

        int x=5/3;                  // returns 1 
        int v=3/2;
         System.out.println(v);     //1
         double vv=3/2f;            // removal of 'f' will result in 1.0
         System.out.println(vv);    // 1.5

Adding a 'short' to an 'int':

// Implicit casting  // 
        int v=3/2;
        short x=2;
        //short c= v+x; // int cannot be converted to short
         int s=x+v;     //
         System.out.println(s);     // return 3

// two different primitives cannot be operated upon. 

short c=v+x; ===> java allocated a memory of '4 bytes' somewhere in memory, without any name. 
                This chunk is of integer type and then copies 1 into that location, and only now
                performs the addition with v(which is int).

    Note: Implicit casting occurs such that there is no data loss. 
            If it were to happen then, it will show error: lossy variable conversion.
            In that case we will have to carry out 'Explicit Type casting'.
            All the casting can happen when we have compatible classes. 
    String s="1";
    int x=(int)s + 1;  // explicit even won't work here
    int c=Integer.parseInt(s)+1; // this works 
    int xx=Integer.parseInt(dd)+3;      // this does not work incompatible types: double 
                                                cannot be converted to java.lang.String
Why such weird conversion?
Normally, the user the data that we get from users are in the form of strings. That is why these become
important.

We also have : 
        JDouble.parseDouble()

Math
=====
        
        int result=Math.round(1.1f);
        result = (int)Math.ceil(1.1f); // note the explicit typecasting
        result = (int)Math.floor(1.1f);
        result = Math.Random(); // Random number [0,1)
        result = Math.max(3,55);



Note: Abstract classes cannot be instantiated.
        NumberFormat number = new NumberFormat(); // java: java.text.NumberFormat is abstract; cannot be instantiated
        NumberFormat number = NumberFormat.getCurrencyInstance();  // Factory method.
        String res = currency.format(1234)
        String mon = n.format(1234);
         System.out.println(mon);       //  ₹ 1,234.00
         String indian_money = NumberFormat.getCurrencyInstance().format(7000);     // method chaining

Reading inputs, Scanning rather
---------------------------------
         import java.util.Scanner;
         ...

         Scanner sc  = new  Scanner(System.in);
         String name = sc.next(); // does not accept spaced input
         System.out.println(name);
         int age = sc.nextInt();    // .nextDouble(), .nextFloat(), nextByte()      But no .nextString()
         String lover = sc.nextLine();      // "Kate winslet" also acceptable.
         String pre_spaced = sc.nextLine().trim();
         
Control Flow
-------------

    if(condition){
        boolean block_scope = true;
    }

    sout(boolean);      // yields error as the 'block_scope' has scope only in side if block
                        // cannot find symbol
    // additionaly below is not valid
    if(condition)
    int x =33;          // declaration not allowed


            
    boolean isHighIncome;
    
    if(income>100_000){
        isHighIncome = true;
    }
    else {
        isHighIncome = false;
    }

    // **Pro-programmig**

    boolean isHighIncome = income > 100_000; 
    // **Pro-programming**

Ternary operator
------------------
    String className = income > 100_000 ? "First" :"Economy";

switch
----------

    String role = "admin";
    switch(role){
        case "admin":
            sout("you are an admin");
            break;
        case "moderator":
            sout("you are a moderator");
            break;
        default:
            sout("you are just a normal employee");  // if none of them cases are true.
    }

-------------------------------------------------------
    
    String s="hello";
    sout(s == "hello");         // prints true          // is not recommended --> reference tyepes

    // instead
    sout(input.equals("hello");     // is fine. 


for each loop
----------------

        String[] fruits = { "Apple" , "Mango", "Orange"};
        for(int i =0; i< fruits.length; i++){
            sout(fruits[i]);
        }

        // alternate and quite cleaner
        for(String fruit : fruits){
            sout(fruit);
        }


Methods
---------
Still working with the "Main" class, which already has 'main()' method which is necessary. 
We will add another method, self defined one. 

        public static void printJunk(){
            System.out.println("there is some junk in the trunk");
        }
Static is used because JVM will not create an object of the Main class, there fore to make 
the method attached to the class(rather than the object) we use the 'static' keyword. 'void'
means this will not return anything back to the calling method(which is 'main()' here). No 
parameter because we aren't passing any 'argument'.
       
        public class Main {

            public static void main(String[] args) {
            // write your code here
                MyUtils.sum2num(3,4);
            }
        }
        class MyUtils{          // default access modifier
            public static void sum2num(int a, int b){
                System.out.println(a+b);
            }
        } // declared in the same file. 

Above code works fine. However, 'public class MyUtils' will throw error, and can be resolved
by creating another file :
    java: class MyUtils is public, should be declared in a file named MyUtils.java

Note: MyUtils.java will not be Runnable as it does not have a main() method. 

Access Modifiers
-----------------

            type            private         public          protected       default
            ---------------------------------------------------------------------------
            class                           yes                             yes

            method          yes             yes             yes     

private: locally available, only available to the class


        public class Main {

            public static void main(String[] args) {
            // write your code here\
                c2.f2();
            }
        }

        class c1{
            public static void f1(){
                System.out.println("I am fucntion one");
            }
        }

        class c2{
            public static void f2(){
                System.out.println("I am function 2");
                c1.f1();
            }
        }

Importance of private
--------------------------

        public class Main {
            public static void main(String[] args) {
            // write your code here\
                c2.f2();    // this is fine
                c1.f1(); // <------------ error: private member cannot be accessed from out
                            // side of the class
            }
        }

        class c1{
            private static void f1(){
                System.out.println("I am fucntion one");
            }
            public static void ff1(){
                System.out.println("I impersonate f1");
                f1();       // within class so no need to use .operator
            }
        }

        class c2{
            public static void f2(){
                System.out.println("I am function 2");
                c1.ff1();
            }
        }


public:
    1.) with methods: makes accessible by any other class. [provided the enclosgin class is also public]
    2.) with class: Makes this class accessible anywhere in the project.=> we can instantiate this anywhere
                    in the project. However, to access its methods make sure you have the access modifier
                    of the methods set as 'public'(not private)
private:
    1.) with methods: makes the class visible only withins package. 

Note: when we are  calling classes from other packages, remember to 'import package_name'.


Object Oriented Programming
-----------------------------

        Class_name reference_var;
        reference_var = new Class_name();  // Class_name() ===> is the constructor for Class_name

The object comes alive only when the 'new' returns the reference.
Objects are runtime concept, and come into picture only during runtime. 


class Car{
    int hp; // instance variable
}


A variable provides us with named storage that our programs can manipulate. Java provides three types of variables.

Class variables − Class variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block. There would only be one copy of each class variable per class, regardless of how many objects are created from it.

Instance variables − Instance variables are declared in a class, but outside a method. When space is allocated for an object in the heap, a slot for each instance variable value is created. Instance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an object's state that must be present throughout the class.

Local variables − Local variables are declared in methods, constructors, or blocks. Local variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor, or block.


What is the point of OOP?
The is code organistion and providing logical structure to our code. In early days, for very small
functionalities it would have been fine, to follow just the procedural method as assisted by C.
But as the dependency, on the computers have increased exponentially, the code written on them 
should become more reliable. When these codes git really big, it becomes very hard to add new 
features and find bugs. But if we have implemented techniques such as
            - modularity
            - clean coding
            - oops
            - and so on.
things become more easier to maintain. And this pushes more progress.            



Inheritence
-----------

public class earth {
    public static void main(String[] args){
        animal ani = new animal("animal",3,34);
        ani.sleep();
        Fish f = new Fish("fish",2,5);
        f.swim(); // access modifier ='default' => available anywhere in the package.
        f.sleep();
    }
}
// animal in a different .java file
public class animal {
    String name;
    int age;
    int speed;

    public animal(String name, int age, int speed){ // default const. no more present
        this.name=name;
        this.age=age;
        this.speed=speed;
    }
    public void sleep(){
        System.out.println("I am sleeping");
    }
}
// Fish in a different .java file
public class Fish extends animal{

    public Fish(String name, int age, int speed){
        // Fish is animal, so it must be created the same way an animal is created.
        // default constructor overwritten
        super(name, age, speed);
    }
    public void swim(){
        System.out.println("Swimming...");
    }
}



Note: 'extends parent_class' is used to impose inheritence. This allows the child to inherit all the 
        PUBLIC methods of the parent class(here 'animal'). find out the exact access modifiers. 
     
      The parent cannot access the child's methods.

Interfaces
-----------
let us create another classes, 'bird' ,'sparrow' and 'chicken' to the above package. The chicken are 
also a birds and sparrows are bird too. So we can see that bird is the parent here.


        public class bird extends animal{
            public bird(String name, int age, int speed){
                super(name, age, speed);
            }
        }

        // another file
        public class Sparrow extends bird {
            public Sparrow(String name, int age, int speed){
                super(name, age, speed);
                // can Sparrow sleep---> yes it is an animal afterall
            }
        }

        // another class
        public class Chicken extends bird {
            public Chicken(String name, int age, int speed){
                super(name, age, speed);
            }
            public void fly(){
                System.out.println("Cannot fly...");    // fly() is being overwritten 
            }
        }

Over-ridding is one solution, when we don't want a particular method to be inherited by the child. 
This is one way. The other way is to use 'Interface', so you see how java provides us with an 
infrastructure, which helps us to better organise our code. That is how we have different, OOPs
each provide a different solution to a common solution to the problems that we face. Java has really
been able to do that.

    Interface is a Contract. Any class that wants to implement that 'interface' will have to 'implement'
all the 'abstract methods' that have been mentioned in that interface.
If in the above example, suppose, we have:
        // removing the 'fly()' method altogether from the 'bird' class
        public class sparrow extends animal implements Flyable{
            public sparrow(three args){
                super(three args);
            }

        // bird MUST  implement the abstract method fly()
        public void fly(){
            sout("flying...");
        }
        }

        // 'Flyable' class is must
        public interface Flyable {
            public void fly();
        }

There are many 'birds' that don't fly, therfore it is in our favour to define an interface 'Flyable',
which 'MUST' be implemented by the class that decides to use this 'Flyable' interface. Sparrow has to
implement this. However, classes like 'Chicken' need not bother about implementing fly(), it can simply
inherit the properties of the bird as usual, and since the bird class does not have 'fly()' method any-
more, chicken will have never 'heard' of flying!

NOTE: A class can 'extend' only and only "ONE" class. But a class can have many interfaces.

Abstract Classes
-------------------
You cannot create an instance of an Abstract class. Abstract methods cannot hava a body.

In the above example: 'animal' class can be made abstract. 
        
        public  abstract class  animal {
            String name;
            int age;
            int speed;

            public animal(String name, int age, int speed){ // default const. no more present
                this.name=name;
                this.age=age;
                this.speed=speed;
            }
            public void sleep(){
                System.out.println("I am sleeping");
            }

            // all animals can move but they do it differently
            public abstract void move();
        }

        public class bird extends animal{
            public bird(String name, int age, int speed){
                super(name, age, speed);
            }

            public void move() {
                System.out.println("Flapping wings...");
            }
        }
        public class Fish extends animal{

            public Fish(String name, int age, int speed){
                // Fish is animal, so it must be created the same way an animal is created.
                // default constructor overwritten
                super(name, age, speed);
            }
            public void move(){
                System.out.println("Swimming...");
            }
            public void swim(){
                System.out.println("I can swim...");
            }

            // Fish , being child of animal has to implement the move function
        }
        public class Chicken extends bird {
            public Chicken(String name, int age, int speed){
                super(name, age, speed);
            }
        }
        public class Sparrow extends bird implements Flyable {
            public Sparrow(String name, int age, int speed){
                super(name, age, speed);
            }
            public void fly(){
                System.out.println("Flying...");
            }
        }


        public class earth {
            public static void main(String[] args){
                animal sp = new Sparrow("bagada",3,21);
                sp.fly();       // this line causes error
                sp.move();
            }
        }

  java: cannot find symbol
  symbol:   method fly()
  location: variable sp of type animal   // <-------------- note the type is animal not Sparrow

replace 'animal' by 'Sparrow' in the creation of the object. An abstract class is a class that has abstract method.
Also the method 'has' to be implemented by the child class(the class that extends it). Another interesting:
we can make an 'animal' type to point at a Sparrow(present in the heap). [ Test whether this can be done
without making the parent class abstract].
    
    public class earth {
        public static void main(String[] args){
            animal sp= new Sparrow("..",3,21); 
            sp.fly(); // only move function can now be accessed using the 'sp' var of type animal
            sp.move();
        }
    }

Note that, you might think that making of animal class an abstract class does not help, as we have to
implement both the move method in both classes(bird and fish). but this provides with a dynamic approach.

public class earth {
    public static void main(String[] args){
        animal sp = new Sparrow("bagada",3,21);
        animal fis = new Fish("machli", 2,10);
        moveAnimal(sp);
        moveAnimal(fis);  // now we don't have to create two different methods 
                    // moveFish() and moveBird() 
    }
    public static void moveAnimal(animal anim){
        anim.move();
    }
}

AND THIS IS AN EXAMPLE OF POLYMORPHISM. WE HAVE USED THE 'IDEA' OF MOVING AND GENERALISED IT FOR 
MULTIPLE CLASSES INSTANCE TYPE. The moveAnimal method can work with all types of animals. 

public class earth {
    public static void main(String[] args){
        Flyable flyingBird = new Sparrow("mfug",3,33); // fine, bcs Sparrow implements Flyable
        Flyable flyingbb = new bird("birddd",3,33); // incompatible types: bird cannot be converted to Flyable
        flyingBird.fly();
    }
}

Only a class(Sparrow) that implements an interface(Flyable), can create objects(in heap) that can be
referenced by the interface class's reference variable(flyingBird, present in the stack).

File Handling
--------------
like System.out, we have System.in, you can look into the class description to know more. 

    import java.util.Scanner;
    File file = new File("myfile.txt"); // java.io
    Scanner input = new Scanner(file);

    while (input(.hasNextLine()){
        String line = input.nextLine();
        System.out.println(line);
    }

    input.close(); // this is also important. 

What happens if the file does not exist in the file location specified. 
Two ways:
        1. public static void main(String[] args)  throws FileNotFoundException {

        2. try{ input = new Scanner(file);}
            catch (FileNotFoundException e){
                e.printStackTrace();
            }
           
Method 1. 
---------
public class general_class {
    public int sub10fromArg(int number) throws Exception{
        // add condition to throw and exception
        if(number < 10){
            throw new Exception("Error message to be written here");
        }
        return number-10
    }
}

in main class-->
    general_class test_class = new general_class();
    try{
        test_class.sub10fromArg(9);
    }
    catch(Exception e){
        e.printStackTrace();
    }
this will display our error message when the exception condition is satisfied. 

Here the exception class was already implemented by java. But we can define our own 'exception' class.
We can do this by extending the 'Exception' class. and continue from there on. When we actually do 
implement our own exception we should to do it in another package. And the import that here we want to use. 
Look it up more when you need it.

File handling : a buffered file reader  
-----------------------------------------
This is an older way.

import java.io.*;

        public class Application {
            public static void main(String[] args) {
                File file = new File("my_file.txt");
                BufferedReader bufferedReader = null;
                FileReader fileReader = null;
                try{
                    fileReader = new FileReader(file);
                    bufferedReader = new BufferedReader(fileReader);

                    String line = bufferedReader.readLine();  // this might throw IOException
                                                        // we can see this in the class definition
                    while(line != null){
                        System.out.println(line);
                        line = bufferedReader.readLine();
                    }
                }
                catch(FileNotFoundException e)
                {
                    System.out.println("File not found!");
                } catch (IOException e) {
                    System.out.println("Can read the file"+file.getName());
                } finally {
                    // this will always run
                    try{
                        bufferedReader.close(); // will also throw IOException, from the definition
                    }
                    catch(IOException e){
                        System.out.println("Unable to close the file"+file.getName());
                    }
                }
            }
        }

Another thing to take care about is that, when the file name is wrong, the FileReader fil....  line 
will run and then code will crash and we will land into the catch block, note that we will have skipped
the part where the buffered reader was assigned something to point to. But now it is still pointig to
null, and we have skipped to bufferedReader.close() // note that we cannot call any method on null//.
That is why we get a 'NullPointerException', and this will be caught by catch block. 
    There should be a better way. The programmer does not have to catch a NullPointerException, becase
we know the thing is going to be null.  'finally' must close the RESOURCES----> this is very important.

In the above the finally should be replaced by

 finally {
            // this will always run
            try{
                //bufferedReader.close(); // will also throw IOException, from the definition
                if(bufferedReader != null){
                    bufferedReader.close();
                }
                if(bufferedReader != null){
                    fileReader.close();
                }
            }
            catch(IOException e){
                System.out.println("Unable to close the file"+file.getName());
            }
        }


Beyond java 1.7, we can use 'try with resource', which implements Autocloseable resource, so 
we don't need to close things manually. 

        import java.io.*;
        public class App_new_file_reading {
            public static void main(String[] args) {
                File file = new File("my_file.txt");
                // try with resource only after java 1.7
                // this gets rid of the finally block
                try(FileReader fileReader = new FileReader(file);
                    BufferedReader bufferedReader = new BufferedReader(fileReader);){


                    String line = bufferedReader.readLine();  // this might throw IOException
                    // we can see this in the class definition
                    while(line != null){
                        System.out.println(line);
                        line = bufferedReader.readLine();
                    }
                }
                catch(FileNotFoundException e)
                {
                    System.out.println("File not found!");
                } catch (IOException e) {
                    System.out.println("Can read the file"+file.getName());
                }
            }
        }

we can also use our own implementation of AutoCloseable : 
        
        class myClass implements AutoCloseable{
            @Override 
            public void close() throws Exception{
                sout("Closing");
            }
        }
