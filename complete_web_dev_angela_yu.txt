CSS
----
<link rel="stylesheet" src="" href="location/of/file/relative.css">

Note that threre is a distinction between 'src' and 'href', where 'src' just embeds the code 
from other place to the current location, while 'href' does not cause waiting of the loading
of the whole page. This is the reasion styles can be put in the head, but <script> are not. 
'href' specifies the location of the 'resource', like the location of the stylesheet.

- Note that inline has higher precidence the internal or external css,code. Hence be careful
while searching for a bug. external<internal<inline.

Css selectors:
--------------
tag_name < classes < id's

one element can have only one id. while one element can have multiples classes. 
Id's have higher precedence over classes. 
Id's have to be unique.     

Pseudo-classes. 
---------------
Html elements have states. after certain action and before it. e.g., :hover, 
img:hover{
    color: gold; // will change the color to gold each time the 'img' is 'hovered'.
}

Making my own website
---------------------
favicons : are the icons that appears at the top of the page in the besides the title. 


Box model:
-----------
The box model of css. Everything is regarded as a box. And the height and width can be manipualted
as required. This can be done either using a 'px' or '%'. to acquire the specified dimension the 
element will force oother elements out the way as well. 
Important: The border is NOT included in the dimension of the element. By default it is 3px on each
side. So adding a border will lead to requirement of some extra space around the actual box. 
    
A box will automatically fit the content, by resizing it if it falls short. Therefore the content 
might appear very close to the edge of the box. So we can add something called padding. These
PADDINGS will further increase the dimension of the box, if it is required. We can think of padding
as space within the box and the content. 

Margin: is the buffer space "OUTSIDE" the box. This will not increase the size of the box.  
It gives spaces between two boxes. 

blocking and inline elements
------------------------------
The blocking elements create, by default, a box that occupies the whole width of the viewport(parent).
While the inline elements ALLOW next element to be right next to them. 
Disadvantage of using inline elements : Their width cannot be changed. They occupy the content's width.
While <div>'s can easily be changed by width or height. Note that this will still NOT ALLOW the next
element to sit next to it. It still occupies the whole of the line. 
Four choices:
    - display:
            - inline   // like <span>, can't change the width
            - block     // width can be changed, but no next element allowed in the same line
            - inline-block // multiple elements allowed + changeable width
            - none          // Takes the element out of the flow of the page.  
Note: 'visibility' is another css property that allows us to hide an element on the page. But HERE
      the space for the element is present , just the element is not visible. 

Note: Although the width of BLOCK element is always the viewport width, the Height is the content
        width. 

      Order comes from the content of the order of content in the html file. 

      Children sit on top of parent by default. <div><h1>HI</h1></div> => HI will be displayed 
      over div [ not behind it]. 
These were the default behaviour, and expected these can be altered using the 'position' in css.
        
        - static        // default, normal flow as per above 3 rules. 
        - relative      // position relative to the default value 
            - left
            - right
            - top
            - bottom
                    Note: It does not affect the position of anything else, even in case of 
                            collision. 
                            It does not take the element out of the flow of the document. 
        - absolute
                    Note: It TAKES the element out of the flow of the document=> others AFFECTED.
                          This is done wrt the parent element. 
            
        - fixed  // remains fixed irrespective of scrolling. 

centering
---------
text-align: center;     // it has to provided in the parent element, of the element which contains 
                        // a bunch of elements which we want to align to center. 
                        // div : contains lot of items
                        // that div is in body => body{ text-align:center}
margin: 0 auto;         // applied to the desired block element.

Font Families
-------------
    - serif
    - sans-serif
    - monospace
    - cursive
    - fantasy
Each of the above font families are available with font types such as Arial, Times New Roman and so on.
fall back font family is put after the intended font families. 
    font-family: "Helvetica Neue", Arial, sans-serif; /* means that if none is available, what ever
                                                       sans-serif is installed will be used.*/
however, if we want to ensure the exactness of rendering of fonts. The obvious solution is to 
use web, as a source of delivery. And Google-Fonts come to rescue. They are commercially free. 
Type faces. 

Dynamic font sizes: By default font appear at 16px, if we use exact values[like 90px], then even if the
    user changes the size to be large, the selected text will remain 90px, because have used absolute 
    height. However, if we want to change height of the fonts as the page is scaled, then we will have
    to use ---> % or em. 1em = width of 'M', convention in action. In modern days: 1em=16px.  
zooming in is different though, zooming will scale irrespectively. 

consider following piece of css:
                    
                    body{
                        font-size: 2em; // could be in percent 
                    }
                    h1{
                        font-size: 3.5em; // could be in percent // 'em' is inherited.
                    }
        Note: the size of h1 will turn out to be 7em, i.e. 7*16px, 112px !
So to avoid this, we have 'rem' in css3. This 'root em' does not do unwanted scaling. 

float: Use it only when you want to wrap the text around the some another div. Sounds similar to 
'inline-block', 'block'... and position: relative.  However, this has to be used very carefully.
Avoid using 'float'  all over the page. Instead try to use 'relative', 'absolute', 'fixed'..


With that now we move on to bootstrap
--------------------------------------
front end libraray... makes it easy to design the front end of our website. Twitter. github. 
After downloading the bootstrap files, you will have whole lot of .css files. Among them is 
bootstrap.css. This class is the key to link the previous concepts to whatever bootstrap does. 
Previously we wrote our own styles.css and accessed it using the <link rel="stylesheet" href="">
This time around we have files that already has 'humongous' number of lines of css codes. That 
has a lot of classes defined within it. And these classes are meant for style particular elements.
For example <button> in plain vanilla html would invoke a button which is quite 'boring'. But 
If we look into the  bootstrap.css file. We will find that there are lot of classes that add 
properties to the button classes. And we can choose from these predefined classes and modify 
our 'boring' looking button into something really good looking. 

It also cuts down the time to desing, 'cause we already have built in classes on the bootstrap off-
icial site as well. However, one must note that this add some bit of complexity to the front end 
part. as we have lot ( and I mean a lot!) of classes that we down know about, and cannot know about, 
even if we wanted to. This might make the webiste files overall, look bloated and heavier than it 
actually should be. 

Instead of downloading the bootstrap files individually to our each website project, we can just 
use the service provided by CDN[content delivery network ]. CDNs have multiple copies of our sites
present at various location on the globe. And it makes the delivery process of the contents of the 
site more efficient. 
Another thing that bootstrap exploits is its popularity. A vast majoriy of the sites use bootstrap, 
so the moment we access a website that uses bootstrap, the smart browswers cache the bootstrap classes
and other required items. And next time we go to another website that uses bootstrap, these classes
need not be downloaded again, this makes the rendering of the website very fast. 

Note: to exploit the caching it has to 'mass-recognisable' using your own dowloaded version does not 
        help. 

WireFraming and Mockups:
-----------------------
WireFraming is a quick process to start the processing of designing. Just the blueprint. 
Mockups are like the final products' screenshot. 

wireframes ==> layout ==> mockups ==> prototypes. 

transform: rotate(45deg); // rotates the element box by 45 deg clockwise. 


Media queries: Using Native CSS=> Making pages Responsive.
----------------------------------------------------------
                
                @media <type> <feature> { ... }

                @media screen (min-width: 900px){ ... }
                @media print { h1{ color: red} }  // while printing on a paper change color-> red. 

                @media (min-width: 900px) {
                    h1{
                        color: red;
                }
                } // if the minimum width of the screen(media) is 900 or greater than 900px. 
                  // Change the color of h1 to red. 
                
                @media (min-width: 900px) and (max-width: 1000px) {
                    h1 {
                        color: green;
                    }
                }
ViewPort is NOT the same as the device screen size. 

CSS selectors:
--------------
            selector1, selector2 {
                background-color: red;
            }   /* selects both selector1 and selector2 and applies the css property.

            selector1 .class_name tag_name {
                font-family: "Montserrat", sans-serif;
            }  /* is used to select tag_name inside of '.class_name' which is inside selector1
    combined Selectors:
            .class#id2 {
                color: red;
            }       /* Note that there id no space between the selectors. 

Before combining selectors, just think that whether this combination will bring a logical
structure and more readability. If the answer is YES, sure go ahead. 

Principles of webdesign
-----------------------
        - Color theory
        - User Interface Design
        - Typography
        - User Experience Design

Color theory:
-------------
red: tells energy, biology, attraction
green: fresh, good.
Yellow: difficult to avoid, color of sun. 
Blue: trust, reliability
Purple: Royality, feminine [pink]

In the color wheel we can combine the colors : adjacent to each other, opposite to each other
a triangle or a perfect square. 

Typography:
-----------
Serif: they have little feet. Inspired from the marble carving. Makes your design look old.
        Provides authority. Legitimacy. 
        - Old Style : Least prominent difference in width fo feet to pillers. 
        - Transitional: lesser difference. 
        - Modern : Most visible. 

Sans-serif: Simple, Sensible, Straightfoward, Approachable.

Manage User attention:
---------------------
        - Making the important part standout. 
        - Layout : wikipedia => not good. 
        - Alignment : Reduce the number of lines of alignment. 
        - White Space : Adding whitespace can make you appear expensive. 
        - Audience :  feel free to break upper rules to fit the audience. 

User Experience
---------------
        - F-Layout
        - Z-Layout
        - With greater power comes greater responsibility. 
            

Bootstrap4:
-----------

.container : They are by default responsive. And it is convenient to have it as a parent.
             By def. has some margin on both sides. 
.container-fluid : Occupies total width of the viewport. This also responsvie.
.btn btn-primary : 


carousel
--------
Tip: First create the content of the caraousels for each slide style them using appropriate
    classes and properties. Then move ahead and put them in the carousel template.  

Buttons [ arrows ] are described using the <span> tags previous and next. 


Code Refactoring
----------------
It is of utmost importance that we write code that are more readable and easy to maintain. 
        - Readability
        - Modularity
        - Efficiency
        - Length 
Maintance does not always have to do with the very very high efficienct code. The code should be
efficient enough, meanwhile is should be more readable so that a person reading it a year later
[ that could be yourself ] can easily understand what is going on. As Angela suggets think of that
person as a murderer. It truly can help you save a lot time and brush upon some skill very very 
quickly. 
Also try to Keep the code DRY. 


JavaScript
-----------------------
Built in 10 days, to make the browsers more dynamic. Has its origin in NetScape, Mozilla. 
They were standardized as ECMA Scripts. ES6 is a version. Initially, built just for toying,  now
it has become the most popular language, because of its simplicity and availability. C++ and Java, 
were regarded as more serious language due to their closeness to the hardware and being compiled. 
JS is interpreted language and it line wise read by the engine. 

typeof()
alert()  // only strings can be printed, so use '+' to concatenate.
console.log() // use ',' to separate. you can use '+' here but, this will convert number to string.
word.length
string.slice(start_index,end_index+1)   // like in python. "test_string".slice(x,y) works just fine.
string.toUpperCase() // returns a string with upper case // the current string remains as such.
string.toLowerCase()
x++, --x    // are all the same as previous c++ // this is not valid in python though.
Math.round(number)
Math.ceil()
Math.floor()
Math.random() // generates a random number [0,1)
===     // exactly same
==      // does not care about the data type. [coersion]
&& AND
|| OR
!  NOT
arr.includes()  // returns true or false based on the presence or absence of the element in the array. 
arr.push(element) // similar to python's append() ==> adds to the end of the list. 
arr.pop;        // no paren, unlike python. 







collections
------------
var arr=[];
 



There is place in google chrome : snippets where we can create our own script and run Ctrl+Enter.
Hard reload and clear cache can be done using the refresh button on google chrome.

Concatenation
--------------
var a="amiay";
var b="naraya";
var name=a+" " + b;

'+' will convert numbers to string.


So we saw how we can use inline CSS code to modify the style of the content on our page. 
        style="background-color: red"

Similarly we have, inline javascript code. 
        onload="alert('hello');"

similarly we have <style> and <script> as internal css and javascript respectively. 

        <script src="index.js" type="text/javascript">  <!-- for external js--> 

DOM
---
Document Object Model

    var heading=document.lastElementChild.firstElementChild;
    heading.innerHTML="Changed_Heading";
This will change the content of the page on the fly. While rendering the element of a page, the
browser converts these elements in the form of a tree. And elements have parent-child relation
among them. However, using plain vanilla JavaScript we can manipulate the content, style and beha-
viour of our page. 
This can be done by selecting the particular element, and then modifying the css ... 
Also, selection can be done in a number of ways. 
So each element on the page is described using an Object, for example, body is an object, a button
is also an object. And so on and on. Hence the Name : D Object M. 
So Being an Object these will also have 
            - Properties : color, background-color, height...
            - Methods : which can change the properties and all sort of other action can be done. 
Example :
<button>
    Properties: innerHTML, style, firstChild
    Methods: click(), appendChild(), setAttribute()

document.getElementsByTagName("h1")         // this will ALWAYS return an array            
document.getElementsByClassName("h1")       // this will ALWAYS return an array
document.getElementById("id_name") // note that this will return single object
document.querySelector("h1 #id_name")       // similar to CSS selector. // RETURNS ONLY FIRST.
document.querySelectorAlL("#list li")[1]    // array hence using indices. 
.getAttribute("href")
.setAttrubute("href", "src")                // sets the attribute to the second string. 

Note: 'font-size' becomes fontSize in JavaScript. Camel-Casing in action. 

<button class="btn">Click here</button>

document.querySelector("button").classList; // returns a list of class associated with "button".
document.querySelector("buttton").classList.add("amiay")   // will add class
So, the new html will be:
        <button class="btn amiay">Click here</button>

We could also change color, height, and all sorts of things using ONLY JavaScript. But this is not
what JavaScript is meant for; ofcourse we will encounter cases where it only befitting to use 
JavaScript to change the CSS style of the element, but normally for general styling we will always
use styles.css.

one use could be to toggle between hiding and showing elemnet. 


styles.css:
        .invisible{
            display: none; // visibility: none;
        }

document.querySelector("button").classList.add("invisible");
The above JS code will make the button go 'invisible'. and we can type following to make it visible:

document.querySelector("button").classList.remove("invisible");
document.querySelector("button").classList.toggle("invisible");

innerHTML vs textContent
------------------------
<h1><p>This is a para</p></h1>
document.querySelector("h1").innerHTML =====> <p> ... </p>
document.querySelector("h1").textContent =====> "This is a para"


Note: while changing the value of the element, make sure to use "", because it is not JS. 


----------------------
Backend
==----================
Any modern day web app consists of three layers: 
    1. Front end : this is the interface to the user. 
    2. server end : This processes the data and serves the user
    3. database : This stores the data 

There are serveral technologies to choose from: 
Java(       ),  nodejs(express), ruby( on rails), php(      ), python and so on. \
Here we will choose Nodejs( and companies like , Netflix, uber also use node and more are joining. )

Recall, that we JavaScript was originally meant to be run only on the client side. Only the javascript 
engines could convert these into a machine code. various browsers had different engines. V8, by google
turned out to be the fastest => popular. But still it was only meant for the browser and making a site
more interactive. Node takes it to a next level. This is a runtime environment that allows javascript
to be used on the server side as well. Javascript, can therefore, be used to create a full fledged
desktop applications! Js can now be run independently.
"A platform on Chrome's javaScript runtime for
easily building fast and scalable network applications. Nodejs usees and event-driven, non-blocking I/O 
that makes it lightweight and perfect for data-intensive and real-time applications that run across 
distributed devices". 

Node allows us to use the hardware directly, for example it can access the file system directly. Other-
wise java script would have been locked on the browsers only.

We can compare Nodejs with JRE(java runtime environment) and V8 being equivalent to Java Virtual Machine(
which is responsible to execute the bytecode that is generated after compilation by javacompiler).

        Push main() onto the call stack.
        Push console.log() onto the call stack. This then runs right away and gets popped.
        Push setTimeout(2000) onto the stack. setTimeout(2000) is a Node API. When we call it, we register the event-callback pair. The event will wait 2000 milliseconds, then callback is the function.
        After registering it in the APIs, setTimeout(2000) gets popped from the call stack.
        Now the second setTimeout(0) gets registered in the same way. We now have two Node APIs waiting to execute.
        After waiting for 0 seconds, setTimeout(0) gets moved to the callback queue, and the same thing happens with setTimeout(2000).
        In the callback queue, the functions wait for the call stack to be empty, because only one statement can execute a time. This is taken care of by the event loop.
        The last console.log() runs, and the main() gets popped from the call stack.
        The event loop sees that the call stack is empty and the callback queue is not empty. So it moves the callbacks (in a first-in-first-out order) to the call stack for execution.

How does a runtime environment work?
An application that’s currently running interacts with the runtime environment via a runtime system. The runtime environment in turn acts as a go-between between the application and the operating system. As soon as a program is executed, it sends instructions to the computer’s processor and RAM, and accesses system resources. The runtime environment thus includes hardware, memory, variables in the environment, and interactions with the user and software components.

A runtime environment provides various basic functions for memory, networks, and hardware. These functions are carried out by the runtime environment instead of the application and work independently of the operating system. They include reading and writing files, managing input and output devices, searching and sorting files, and transporting data via networks.

 Note
The individual modules of a runtime environment are saved in runtime libraries. In Windows, you can identify these libraries based on the extension .dll (dynamic link library); in Linux they have the file suffix .so (shared object).

-------------------------------------------
Node has to be installed on the system before we start to work on it. 
Getting started
---------------------------------------------
        mkdir intro-to-node
        cd intro-to-node
        touch index.js // typically we linked this file to our index.html, so that V8 engine of the browser
                        // could execute it. But here we don't. This will now be handled by Nodejs
                        // Now we have the power to run it on the command line itself. 
        cat >> index.js
        console.log("Hi there")
        node index.js   // prints "Hi there" on the screen.
Native Node Modules:
These are the libraries that come bundled with Node(built by the Node team), that help us attain
various things such as accessing the local file system. To be able to use the modules we need to 
incorporate it into our project=> "Require"
    
        const fs = require("fs"); // includes the module
        fs.copyFileSync("file1.txt", "file2.txt")       
        // Above copies the content of one file to another file.
        // Note that this type of operation allows us to use javascript like python, java or C++.

Native Node modules are already comes along with the download. With the download also comes the 
npm, node package manager. This is very very very famous as it is the largest number of modules
there. These modules are not "Native", they are external. These are written by other developers. 

        var super_villains = require("supervillains");
        var name = super_villains.random();        
        console.log(name);
        

        node index.js       // will throw an error, as this is External module, and we have to
                            // npm to install, for that we have to do an -> 
                            // npm init
                            // npm install supervillains --save
                            // npm index.js         // spits a name. 
One more thing we can notice is that: this external module is now a dependency. Therefore, 
this will be added to the package.json, which was created when we did 'npm init'.

Express
---------
Remember javascript had jquery, which made our life a lot easier. Similarly here we have 
express for Node. Express is a framework, which helps in developing web applications. It
does so by reducing the repetition, if we were to write the web app with only Node out of
the box. It is obvious that express is an external modules => we will have to install it
using npm. 
        npm install expres --save       // --save is default
        // this will also create 'node-modules' directory.

// inside server.js
        const express = require("express");
        const app = express();  // a function that represents the express module
        app.listen(3000);       // this server will listen to requests on port 3000
                                // it listens to http request at port 3000. 
// on running this server 'node server.js' // the command lines 'hangs', it waits for a request
on the specified port. 

when we open 'localhost:3000', on the web-browser, there is an error
but now if we start the above server on the terminal, Cannot GET /
This is because our server does not know how to a 'GET' request. It is ofcourse listening now on 
port 3000, but does not know how to respond.
        // add the following
        app.get("/", function(request, response){
            console.log(response);
        });
This will still cause Cannot GET / , but now we can see a whole lot of info on the terminal where 
the server is running. 
            // change the call back
            response.send("hi there"); // error will be gone and we see the message on the browser
                    or 
            response.send("<h1>Hi there</h1>");// we can also send html

anatomy of get request
-----------------------
.get(route, callback){
    response
    }
we can have different requests made at different routes, and we might want send different responses
for each of these routes. Here the concept of routes comes handy. 

Note: starting and restarting the server each time we make a change becomes a pain in the ass.
'nodemon' to the resque. 
        npm install -g nodemon      // I already had this. // like liteserver and npm start 


We can also send file as a response to requests. 
        res.sendFile(__dirname + "index.html")      // sends an html file as a response

post 
----
suppose we wanted to do some calculation on the server side. (say addint 2 numbers). In that case
we need to be able to post some data to the server. These can be collected using a form. 
        <form action = "/" method = "post">
            <input type = "text"> 
            ...
        </form>

This will not work we have app.post() method implemented on our server.js.[404 not found] or cannot Post /
so we need to implement that. 
        app.post("/", function(req, res){
            res.send("thanks for posting");
        });

Only now the post-request is successful(Note that server has performed on the data yet). 
    post request is the form data. and the response is : " thanks for posting"
Now we have to be able to use that data on the server so that we can carryout our logic on the data
obtained. And return something meaningful. 

For this purpose we use 'body-parser'. 
        .urlencoded()
        .json()
        .text()     // are some of the modes provided by the parser. 

include the line below to use the parsed form of data posted.
        app.use(bodyParser.urlencoded({extended:true}));
        app.post("/",function(req, res){console.log(req.body)});

        // on the server terminal 
        { num1: '3', num2: '4', Calculator: 'Calculate' }


APIs
----
Application Programming Interfaces
An application programming interface (API) is a computing interface that defines interactions between multiple software intermediaries. It defines the kinds of calls or requests that can be made, how to make them, the data formats that should be used, the conventions to follow, etc.APIs let your product or service communicate with other products and services without having to know how they're implemented. This can simplify app development, saving time and money.

        1. Endpoints: https://api.kanye.rest/        : is an example of endpoint, a GET request is made
        2. Paths :   narrow down your search of data 
        3. Parameters: This also helps https://sv443.net/jokeapi/v2/joke/Any?contains=hello
                this allows more flexibility, as everything can not be thought before hand and put
                in as a route. https://sv443.net/jokeapi/v2/joke/hello, may be it does not exist and 
                will throw an error. To get rid of that we can provdie parameters using '?'. Multiple
                parameters are chained using '&'.
                Parameters are nothing but key-value pairs.
        4. Authentication: 
http://api.openweathermap.org/data/2.5/weather?q=London&appid=52884f523158675d8a622ffe4bc73f03&units=metric
is an example of api call and we get the following response: 
{"coord":{"lon":-0.13,"lat":51.51},"weather":[{"id":802,"main":"Clouds","description":"scattered clouds","icon":"03n"}],"base":"stations","main":{"temp":10.61,"feels_like":7.23,"temp_min":10,"temp_max":11.11,"pressure":1020,"humidity":88},"visibility":10000,"wind":{"speed":4.41,"deg":193},"clouds":{"all":43},"dt":1606199770,"sys":{"type":3,"id":2019646,"country":"GB","sunrise":1606203250,"sunset":1606233651},"timezone":0,"id":2643743,"name":"London","cod":200}

Note: The order of query does not matter. 
also, it is very difficult to type and work with chrome directly to make requests. So we use Postman. 

The data that we received is in the format of JSON. [ Advantage of using api over webpages is that, we 
get faster parsing and the business logic can be abstracted]. Note the below:
        var javascript_object = {
            name : "amiay",
            roll : 11640140
        }
However in json, the keys are also strings.
The weather app
----------------
we create app.js, when a get request is made to this server(app.js), it should in turn make another api
call to 'open weather' server and fetch the JSON data. And then app.js should 'respond' with that data. 
Till now we know that we can respond with a string message or html file :
        res.send("Hi this is the response to get request");
        res.sendFile(__dirname + "/index.html"); // sends a file

We want to make a request to open weather server, this could have been done with the help of 'request' 
module(external module). But as of 2020, this has been deprecated. 
Therefore, other ways are :
        1. https : native standard library of node
        2. axios : external module
        3. got
        4. superagent : external module

we will use the native module- https. to incorporate add 
        const https = require("https");
        app.get(........){
            https.get(api_url, function(res){
                console.log(res);
            });     // this will log the response to the app terminal
        }
The response will have a lot of information. We have to now parse that information to be able to get 
the information that is required. 

To get the statusCode of the response we can: 
                console.log(res.statusCode);
                // 200 -> OK
                // 404 -> resource not found. 

To get the data, in the format we want. we can use:
        res.on("data", function(data){
            console.log(data); // logs incoming data from open weather as Hexadecimal\
            const weather_data = JSON.parse(data);
            console.log(weather_data);  // logs the pretty form of data on to the terminal 
        }); 
        // if the response has any data, then the above function will log the data on the app.js terminal
Note:
----
We can also reverse the above step. JSON -> String 
    var object  = {
        name : "amiay", 
        color : "red",
        iq : "high"
    }
    var flat_object = JSON.stringify(object); // packs into a single string
===========================================================================
            const descript = weather_data.weather[0].description;
            console.log(descript); 
Note: 
we can res.send() only once for a particular app.get() request. Therefore to send multiple data
we have to use, res.write() each time and finally send the data using res.send().

                const weatherIcon = weather_data.weather[0].icon;
  1             var icon_url = "http://openweathermap.org/img/wn/"+weatherIcon+"@2x.png";
  2             console.log(icon_url);
  3             response.write("<img src ="+icon_url+">");
  4             response.send();

http://openweathermap.org/img/wn/01d@2x.png <----- is the generated url.

Below is the whole code to implement it roughly

        1   const express = require("express");
          1 const https = require("https");     // does not require npm install, as 'https' is native module
          2 const bodyParser = require("body-parser");
          3 const app = express();
          4 app.use(bodyParser.urlencoded({extended:true}));
          5
          6 app.get("/", function(req, response){
          7     // we want to make an request to open weather server using its api
          8
          9     response.sendFile(__dirname + "/index.html");
         10     });
         11 app.post("/", function(req, res){
         12     const query = req.body.city;
         13     const appid = "52884f523158675d8a622ffe4bc73f03";
         14     const units = "metric";
         15     const url = "https://api.openweathermap.org/data/2.5/weather?q="+query+"&appid="+appid+"&units="+units;
         16     https.get(url, function(response){
         17         response.on("data", function(data){
         18             const weatherData = JSON.parse(data);
         19             const temp = weatherData.main.temp;
         20             const icon = weatherData.weather[0].icon;
         21             const description = weatherData.weather[0].description;
         22             const icon_url = "http://openweathermap.org/img/wn/" + icon + "@2x.png";
         23             res.write("<h1>The temperate of "+query+ " is: "+temp+"</h1>");
         24             res.write("<p>"+description+"</p>");
         25             res.write("<img src="+icon_url+">");
         26             res.send();
         27         });
         28     });
         29
         30 });


+=======================================================================================================

Newsletter project
-------------------
We use a template from bootstrap. Also, note that bootstrap will be delivered using cdn. This page
also makes use of a custom stylesheet. This has to be linked. But when you set up your app.js.
you send this file(form that we created using bootstrap) :
    app.get("/", function(req, res){res.send(__dirname+ "/signup.html")});
This will however not be able to make use of static resources such as the custom stylesheet and the
local images. For that we will have to include the following line:
        app.use(express.static("public")); // here public is the folder that is static

set up the mail chimp account. And get the api key (you don't want any strange person to change the 
list of subscribers). To manage the audience you also will have to get the unique id for audience. 
https://us7.admin.mailchimp.com/lists/settings?id=514628    <- is the link to get it. 

The detailed implementaion can be seen at ~/learn/Udemy/angel..../news-letter-project/

Basically we are using our server to listen at port 3000, 
        - first when a get request is made at "/", our server returns the signup.html
        - then when a post request is made from the form present here( at signup.html), the servers
            resolves that can stores the info(firstName, lastName, emailId). 
        - now the server makes use of https.request(url,option, funtiont(response){})     to talk to
            the mailchimp api. This step requires you to be precise, as protocols are strict and 
            cannot be surpassed. 
        - the response of this api is 200 if everything was alright.
        - Overall, it is very good exercise to get used to requests(post, get) and get familiar with
            apis.
But till now we have only been able to list to port 3000 on the localhost. But how do we make this 
available on the world wide web. We can indeed make our own servers and endure the pain of managing it
and do the labour that is essentially required to keep it maintained up and running. 

So we rent servers: Heroku comes to help here. 
        sudo snap install heroku --classic      # installs heroku cli
        heroku login                            # will sign you in
        # requires  node, git and npm
Create a git repository of your app
Create a Procfile, with 'web: node app.js'
        git init
        git add .
        git commit -m 'some comment'
        heroku create       # green blue means => everything ok
        git push heroku master
        heroku ps:scale web=1   # to ensure atleast one instance of your app is running
        heroku open             # to open your app in default browser
                                # Basically this will make get request on the app.js
                                # So the app will respond with home route, which in our app
                                # is the sign up page, we can carry on after that
Make sure that you have changed the port setting as well, there is no guarentee that port 3000 will 
be free, on the heroku server it has been deployed. 
        3000 ------> process.env.PORT || 3000

       heroku logs --tail      # be sure to check the logs, both in case of failure and success.


Templating
------------
Probelm : we can use the res.send() only once within a app.get(). So what to do when we have multiple
lines of html or other data to send. We can use res.write() each time and then send everything at the
end. But this also is very repetitive. Solution: we can send files using res.sendFile(). However, this
can also, sometimes, becomes tedious. Just for sending small data we have to write a whole lot of html
code.       ---------- The solution to this Templating ------------------
    
The software that we are going to use for templating is EJS.
        npm install ejs --save
        app.use("view engine", "ejs");      // declares that 'ejs' will be used as view engine
        mkdir views
        touch views/index.ejs
        // edit this 'index.ejs' file as follows 
        <html.... boiler plate

            <%= kindOfDay %>        // this will be the variable that will change its value
                                // according to the data that is sent over as a response

        </html>

        var weekday ---> has the value that will be sent to the list.ejs.

also the res.send() will now be changed to :   res.render("list", {kindOfDay: weekday});
'list.ejs' is the name of the template file, that we want to give some value to. This will 
complete the page. 
ejs also allows to run code on the html template itself. For example if the value that was
passed to the template is >6 then change the background of the page. Or could be any other
control flow requriment, that is easy to do on the html page itself. However, don't try to
stuff too much on the template. Limited is fine. 
Note: For every line of javascript you will have to add     <%  java...script %>
Like the following : 
  1             <%if(kindOfDay === "Saturday" || kindOfDay === "Sunday"){   %>
  2             <h1 style="color:purple">It is a <%= kindOfDay %></h1>
  3             <%}else{ %>
  4             <h1 style="color:blue">It not is a <%= kindOfDay %></h1>
  5             <% } %>

<% ----> is called 'scriptlet' tag. there are other tags as well. Check the docs of EJS.

Note: Formatting dates.
----------------------
        var today - new Date();
        var options = {
            weekday : "long", 
            day: "numeric",
            month: "long"
        }
        var day = today.toLocaleDateString("en-US", options); // this will check with operating system
        res.render{
            kindOfDay: day
        }


Now how can we pass data from the template to the server? 
This can be done with the help of post request.
        app.post("/", function(req, res){
            items.push(req.body.doItem);    // items was an array
            res.redirect("/");              // redirects to post at "/"
        }
Note: If there are two variables, one that changes value in app.get and the other changes the value in 
app.post(). There is a problem. One type of response will be sent at one time. So the other variable will
be left empty. This will create problem in res.render(), So to overcome this we will always have to send 
all the data(missing) everytime we want to render that .ejs template. This should be handled using scope
of variables and proper initialisations. 

When a form is submitted. We can look at all the data that is posted:
    console.log(req.body)       // { next_item: 'code', list: 'Work' } // second related to button
                                //    name: entered_value     name:value
So, we can use name:value to dynamically assign <%varialbe%> to 'value'. This will help us uniquely
identify the post request. 

ejs - LAYOUTS
-----------------
small changes can be handled easily, accross multiple webpages, using 'scriptlets'. But this 
is not a great way to generalise for webpages that changes drastically, however some data are
consistently same throughout, like header or footer. 
here layouts come to resque. 
        <%- include("header") -%>
        ...
            some content specific to this page. 

        ...
       <%- include("footer") -%>

Modules in JavaScript
---------------------
        const express = require("express");     // means we are calling a module named 'express'
Similary we can create our own modules. 
        
        // another file 'date.js'
        console.log(module);        // module refers to the current module , similar to 'this'
        console.log("hi");          // this runs    
        function() getDate{
            let today = new Date();
            let options = {
                weekday : "long",       // But this does not run.
                day: "numeric",
                month: "long"
            };
            let day = today.toLocaleDateString("en-US", options);
        }
        // in the app.js
        const day = require(_dirname + "/date.js");     //This does not run the module,  
        console.log(day);                               // Logs empty object.

Binding and exporting
-----------------------
We can export certain string, function or objects from a module and use them when we 'require'.
        module.exports = getDate;           // binds the function 'getDate' to export
        // in another file
        const date = require(__dirname + "/date.js");
        let day = date();       // funtion exported gets bound to date, and we can call it whenever 
                                // we want. 
Note:
-----
'module.exports' is so common that there is a shortcut
        exports
module.exports is an object, hence it can have properties and behaviours => we can export multiple.
    module.exports.getDate = getDate;
    module.exports.getDay = getDay; 
    // these can be used in another file after requiring
    date.getDate();
    date.getDay(); 
During exporting, we can also try to make it more succinct using anonymous functions. 
        // when we export in the above way, exports object has two functions that we can tap into.
        exports: { getDate: [Function: getDate], getDay: [Function: getDay] }


Two handy ways of loop
-----------------------
Method 1.

        var array=['amiay', 'nara', 'yan']

        array.forEach(function(element){
            console.log(element);
        }

Method 2.

        var array = ['tit','for', 'tat'];
        for(element  of array){
            console.log(element);
        }

These two methods save the pain of writing, array.length.

Route Parameters
-----------------
Though regular expressions used in the route can provide flexibility as well. But Route parameters
are better way to do it. 
        app.get('/users/:userId/books/:bookId', function (req, res) {
          res.send(req.params)  // params will have the parameter provided in the url.
        })

        Route path: /users/:userId/books/:bookId
        Request URL: http://localhost:3000/users/34/books/8989
        req.params: { "userId": "34", "bookId": "8989" }    // Json object that we get as the data. 

WE can carry out, all sorts of operations using the  data that is passed on the navigation bar, we can 
check the presence of that parameter in the data present on the server and so on. 

Lodash
-------
It is another utility that enables us to do lot more with Nodejs. 

    const _ = require("lodash");
    var some_string = "hi this is me";
    some_string = _.lowerCase(some_string);
    some_string = _.truncate(some_string, {"length":100};

Lodash great with strings and array, check the online documentation to use more of its features. 


Databases:
--------------
Every time the server restarts, the data present on the server is also lost. Because it was stored
as global variables and arrays. So to have a persistent data, we have to have some physical storages.
And to manage and structure the data so that they can be efficietly used, we must also have database
management systems(softwares). 

Now in the current market there are two major players, 

SQL: MySQL, Postgres
NoSQL: MongoDB, Redis       [no only structured query language]

MySQL :       
    1. More Mature
    2. Table structure
    3. Require a Schema
    4. Great with relationships
    5. Scales vertically  [ vertically scaling is not the solution, height is limited]

MongoDB :
    1. Shiny and new : More prone to changes
    2. Document Structure
    3. more Flexible to Changes
    4. not great with Complex Relationships
    5. Horiaontally Scalable ==> which will require to store the data on multiple systems. 

--------------------
SQL:
--------------------
Note: There are four operations that we will be doing, as can be suggested by the https CRUD requests.


--------------------
MongoDB:
--------------------
Collection: Is equivalent to tables.
Document: Each record in the collection is called a document in mongodb lingo. Each document might
        have different schema. Flexibility.
MongoDb stores data records as BSON documents(binary representation of JSON).
After installing Mongodb using its tarfile and following all the process. To get started , start 
the daemon on one terminal :    
        sudo mongod
On the other terminal open the mongo shell, using : 
        mongo


Commands :
       
        help
        show dbs        // it has 3 preloaded db : admin, config, local
        use shopDB      // creates new data base named : 'shopDB'
        db              // gives the current database you are in 
CRUD
----
    db.collection.insertOne(..)         // collection is the name the collection e.g., users
    db.collection.insertMany(...)
    // example
    > db.products.insertOne({_id:2, name: "Pencil", price: 0.80, stock: 12})
    { "acknowledged" : true, "insertedId" : 2 } // output
    //READ
    db.collection.find(query, projection)   // 
    db.products.find()      // finds all the document of the collection.
    db.products.find({name: "Pen"})
    db.products.find({price : {$gt: 1}})        // we can add conditions as well, [documentation]
    db.products.find({price: {$gt: 1}}, {name:1, _id:0})    // projection is used to specify the 
                                                            // fields particularly
    //UPDATE
    > db.products.updateOne({_id:1}, {$set: {stock: 32}})
    { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
    //DELETE
    > db.products.deleteOne(.....)

we can also add some complex documents:
        db.products.insert({
                _id: 4,
                name: "Ink",
                price: 2.3,
                stock: 24,
                reviews: [
                        {
                                author: "amiay",
                                rating: 3,
                                review: "The was a magic ink"
                        },
                        {
                                author:"swati",
                                rating:4,
                                review:"The was a Dark ink"
                        }
                ]
        })

Driver
-------
To be able to connect our app with the data base, we need to have some driver. The official way
to do so is, MongoDB Node.js driver. The driver features an asynchronous API which allows you to
access method return values through Promises or specify callbacks to access them when communcating 
with MongoDB.
    // install the driver
    npm install mongodb

One thing to note is that, MongoDB being newer, there are frequent changes in the way we connect 
to the database, using async or simple function, try-catch and so on. So go through the document
-ation. Also one important thing to note is that, we can verify our entry into the database, using
        assert.equal(3, result.ops.length);// or similar statement of comparison

1   const { MongoClient } = require("mongodb");
  1 // const MongoClient = require("mongodb").MongoClient;      // above is same as this
  2 const assert= require("assert");
  3
  4 // Replace the uri string with your MongoDB deployment's connection string.
  5 const url =
  6   "mongodb://localhost:27017";
  7
  8 const client = new MongoClient(url, { useUnifiedTopology: true });      // second param gets rid of warning
    ... 

Similarly we have way to CRUD using this native module. It does not take too much time to realise
that we this really 'wordy'. So we have a solution : 'mongoose'

mongoose:
---------
It 'bigly' simplifies our lives, by making connection, crud one liners. It is object document mapping.

        const mongoose = require("mongoose");       // ofcourse you have to : npm install mongoose
        mongoose.connect(.......);
Here we have to create a new schema. This schema will provide structure [ kind of blue print to our db].
        const fruitSchema = new mongoose.Schema({
            name: String,
            rating: Number,
            review: String
        });

Then we have to create model. Also keep in mind the convention used for naming the collections
        const Fruit = mongoose.model("Fruit", fruitSchema);     // creating collection with schema
        const fruit = new Fruit({
            name: "Apple",
            rating: 7, 
            review: "Pretty solid as afruit."
        });
        fruit.save();       // this inserts the fruit into the collection (fruits not Fruit.... uses lodash).

To automatically close 
mongoose.connection.close();

Note:
-----
while defining the schema we can also define some validation(head to the documentation). This can be 
        rating: {
        type: Number,
        min: 1,
        max: 10
        }
Validation is important feature and it is made easy using 'mongoose'. 
Similarly, update and delete can also be looked up from the documentation. 

Making things persistent
--------------------------
We stored data in arrays that reside on the ram. But now we have the tool required to be able to
store things on the disk using mongoose/mongodb. 

To tap into the entries of the data base, first set up all the pre-requisites: mongod, require(...).
Whenever a post request is made, 
    const new_tast = req.body.next_item;
    const task = new Task({new_task});      // note that model 'Task' has already been created
    task.save(function(err){
        if(err) return console.log(err);
        console.log("Entry saved successfully");
    });     // this has to be done for each post request.// 

    // now querying the data
    // Method 1. => Query the whole document every time and select only the required field
    // inside app.get("/", function(req, res){
        Task.find(function(err, items){
            if(err) console.log(err);
            res.render({
                title: day,
                taskName: items         // items is an array of objects 
            });
        });
    });

    // Method 2. => just query the required field name 
    const query = Task.find({}).select({"taskName":1, "_id":0}); // just specifying the projection
    query.exec(function(err, items){
        if(err) return console.log(err);
        res.render({
            title: day,
            taskName: items         // this will send {'taskname': 'code'} // still not enough
        });
    });


    // syntax of .find()

    Task.find({condition}, function(err, results){
        if(err) return console.log(err);
        // use 'results' documents
    });

posting a request to delete from database
--------------------------------------------
  1 app.post("/delete", function(req, res){
  2     const to_be_deleted_id = req.body.checkbox;
  3     Task.deleteOne({_id:to_be_deleted_id}, function(err){
  4         if(err) return console.log(err);
  5         console.log("Successful deletion");
  6         res.redirect("/");
  7     })
  8
  9 });

Important Note:
------------------
'name' and 'value' are two important attributes that we can cleverly exploit in order to make 
our life easier. However to a frontend poerson it might seem that these two attributes are 
quite useless. These two attributes can be used to differntiate on request from another and 
carryout different logic in our app.js. 

Adding to an existing array in a document
-------------------------------------------
  1     List.updateOne({name: customListName}, {"$push": {"items": [task]}},function(err, result){
  2         if(err) return console.log(err);
  3         console.log("Item added successfully" );
  4         });

  //another way 
  List.fineOne({name: customListName}, function(err, foundList){
    if(err) return console.log(err);
    foundList.items.push(task);     // task = new Task({....})      
  });

Going global
---------------
Previously we used 'heroku' to host our nodejs app[ the mail chimp app for subscription]. This
time we will also need to host our database on some server that runs 24*7. This functionality
is provided by 'Atlas' from mongodb itself. 
We have to follow the steps inorder to get the database live as cluster.    

RESTful API
-----------
Build our api. REpresentation State Transfer.We have already seen about how cool these api's 
are and how we can use one in our own app. But now how do we build one. There are several 
architectural styles that one can follow to build one. 
        1. SOAP
        2. REST
        3. GraphQl
        4. Falcor
REST basically proposes to use the same types of protocal for each and every api in the world.
This would make things really really uniform. This also proposes the use of https verbs.
        1. GET: read
        2. POST: basically create
        3. PUT, PATCH : update; patch is selective updation
        4. DELETE
Specific patterns of routes are also important for http. 
To work with this section we will use, robo 3T. This is gui to use monogdb. Here we create a new
collection (be sure to check the convention for naming)

app.route("/articles").get(function(req,res){}).put().delete();

This allows us to improve upon the maintainability of the code, by avoiding error.
Refer to 'wikiDB' api folder in the study material

.put()      // inside we will put the update() operation
This basically changes an entry as a whole.  

Tip:  %20 is denoted as ' ', while putting it on the https://localhost:3000/articles/:articleTitle 
is the route where we want to 'update' or 'PUT' our changes to. And if field name is - title and the
the specific title is "abhay narayan", the we need to pass "https://localhost:3000/articles/abhay%20narayan
as the url to be able to update. Along with that we must also be able to supply the 'payload' the 
new data that will replace the old one. 
.put(function(req, res){
    Article.update{title: req.params.articleTitle}, {title: req.body.title, content:req.body.content},{overwrite: true} function(err){...usual suspects here...});

Note that the above operation will replace the entire document, even if only certain fields were specified
in the put request[which we intended to overwrite]. 
If we wanted to update ONLY CERTAIN part of the document then we go with the "PATCH" option.
        
        .patch(function(req,res){
            Article.update({query}, {$set: req.body}, function(err){
            if(err) return console.log(err);
            res.send("update successfull");
            });
        });

Authentication
--------------------
There are various levels of authenticationa and security that we can apply to our site. This choice
will depend upon the audience we are catering to and the product or the service we are providing. 

Level 1
--------
This is just simple creation of a login page, where the user will enter the password and username 
and he should be directed to the required page if the credentials are correct. These 'sensitive' data
are stored as simple plain text[ something to be very worried about]. there are various vulnerabilties
to the system. But then, this is just the start. 

Level 2
--------
Encryption: using the key to encode and decode the sensitive information. It uses two parts in the 
actual use case: encryption and authentication( AES  +  SHA). It also makes use of the BSON format. 
    npm install mongoose-encryption


READ THE Documentation of the "encrypt" plugin and the mongoose-encryption
//in the app.js
        ...
        const encrypt = require("mongoose-encryption");
        const userSchema = new mongoose.Schema({.....});
        
        const lsecret = "Thisisourlittlesecret";     // LONG_STRING_THAT_IS_UNGUESSABLE
        userSchema.plugin(ecrypt, {secret: lsecret, encryptedFields: ["password"]});   
Note: while .save() --> the mongoose automatically encrypts & while .find() it automatically decrypts
    
    YdwF4CCEghZ5GKhnFqBAqb4SD+lEmdCampzEUA3jvQKgWyJfaWQiLCJfY3QiXQ==
    // is the encrypted information
    
However one drawback is that since we have exposed the 'seed' for encryption, therefore we have to be
worried. Because once someone gets access to the website's source code one could easily use that as 
a key to decrypt our site. 
But on the flip side we need these information and keys to be present so that app works as intended. 
This conundrum can be solved using something called environment variables. This can be used in the
project with the help of a very popular package---->    dotenv  or .ENV

require and use this package as early as possible in the app.js. :
        require("dotenv").config(); // at the top of our document. 

        touch .env      // create a file in the project directory directly
        // in side .env file
        API_KEY=this_is_the_api_key_itself              
        //
Note that there are no ; or spaces. there will be no 'const'. Also note the capitalization.             
And while using it in the app we have to use it as follows:
        
        process.env.API_KEY             // reminds the way heroku stores the port number

Note:
This .env file should be added to the .gitignore file before uploading it to remote. 
However, for hosting solutions this is quite different, like heroku, it gives a separate panel to 
write our environment variables. 

Level 3 : Hashing
-----------------
Hashing is a way of identifying information not encoding it. It is one way, unlike encryption. This
can be used to verify the authenticity of a document. A hashing function basically takes input and
spits out a string that is unique. However, absolute uniqueness is not guarenteed, given that coll-
isions are possible. There are several hashing techniques as well: md5, SHA-1, SHA-256 and so on. 
Ofcourse some are weak and some are stronger to defeat. Here we are using md5[not recommended]. 

When the user registers the password gets hashed and the real password in not stored at all but the 
hashed one. Next time when the user tries to log back in, the password is converted back to its hash
and matched against the actual password in the database. And process is complete. 
Now MD5 hashes can be cracked, if someone is motivated enough, there are also very large databases that
have been made on the internet. These are ofcourse of very commong passwords used on the internet. 
There are other hashing algorithms that make the job difficult. But one other neat technique that we
can use is that we can add some random string to the passwords that have been inserted by the user.
This makes every password very unique(however, not truly unique though). md5 is one of such functions.
One very secure one is bcrypt. To further increase the security we can add rounds of salting. As the 
increase in the computing power we can just add another round of salting. And we get multiple times
more secure. 
    npm install bcrypt

    // in app.js 
    const bcrypt = require("bcrypt");
    const saltingrounds = 10;
    app.post(... while receiving the password apply the hash and salting...);

{ "_id" : ObjectId("5fc8b43c95eb7357363f30d2"), "email" : "a@b.com", "password" : "df9f7c813fdc72029b41758ef8dbb528", "__v" : 0 }                                   // only md5 
{ "_id" : ObjectId("5fc90a33a9652da7b0cd4f45"), "email" : "c@d.com", "password" : "$2b$10$R3TY02TgzwgMY1.mG.2xd.Bo72a4rr1NZNveV9klOlSPyZIqMkpJK", "__v" : 0 }       // hashing
{ "_id" : ObjectId("5fc994de795a8e30920fe125"), "email" : "g@h.com", "password" : "$2b$10$YYjR.69Nw1zbNP0ImuU9L.mVS7Y78iC9V1SUSoQLHxGyRHNwF8Iqu", "__v" : 0 }       // hashing with salt

Cookies and sessions
---------------------
Session is the time when the browser interacts with the server,(in continuous manner?). These are
generally some ID that is assigned to each cookie, and these represent a session. And when you go
to someother sites or come back after some time. These cookies get sent to the server and these
server 'try to remind' you of the session(or products in case of amazon). 

Passport
---------
It is authentication middleware of Nodejs. 
        npm install passport passport-local passport-local-mongoose express-session
        // in app.js
        const passport = require("passport");
        const passportLocalMongoose = require("passport-local-mongoose");
        const session = require("session");

        app.use(session({
          secret: 'keyboard cat',
          resave: false,
          saveUninitialized: true,
          cookie: { secure: true }
        }));
        app.use(passport.initialize());;
        app.use(passport.session());
        
        // make sure you have schema declared using mongoose.Schema()
        userSchema.plugin(passportLocalMongoose);
        // after creating the model from schema
        const User = new mongoose.model("User", userSchema);
        passport.use(User.createStrategy());
        passport.serializeUser(User.serializeUser());
        passport.deserializeUser(User.deserializeUser());

        // Note the order of the code, it is very important
You also have to update the app.post("/register") and post for "/login" as well. Make sure
to go through the documentation of passport and express-session. 
Note: the session will create a cookie, inorder to mark the session. Once the localhost cookie is
deleted the, session is no more. 

Level 6
---------
OAuth2.0
---------
Using a third party allows to save the hassle that is involved in providing high degree of security
to the clients or users. So we the common developers turn to big tech organisations that have already
worked and made very complex mathematical ways to keep the data secure. So we can just use them. 
OAuth has three features that make it very good:
    1. Granular Access levels : It allows the developer to ask for only specific fields to be fetched
                    from 'facebook' or 'google'.
    2. Read/Read+Write access : We can make a request for both reading and/or writing to their data base.
        That will ofcourse based on some prearranged contracts. This can be setup at their developer 
        console, that they generally provide. next step is redirect to authenticate, S3, Logs in. S4 user
        grants the permission. S5. receive authorisation code. Now we can allow the user in. or go 
        for S6. we ask for authentication tokens. 

React
-----
A JavaScript library for building user interfaces. A front framework. It makes it very easy to 
create repeated-components. G











Some useful websites
----------------------
colorhunt       : lets you choose hex code of nice colors 
flaticon        : lets search for icons... a huge collection
giphy.com       : animated gifs
codeply.com     : write code for bootstrap.
ui-patterns     : choose UI patterns according to your needs. 
dribble         : designer have put forward their port-folios. 
sneakpeekit     : printout and start 'wireframing'
balsamiq        : industry standard
bootsnip.com    : snippets of various useful template (pricing, navigation), to get inspiration from. 
mobilefriendtest: tests how mobile friendly your site is. 
adobecolorpalet : Lets you play around with colors and select color combination 
canva.com       : online graphic editing program. Something you can quickly build and SHOWCASE. 
idiomatic.js    : Living doc. => everybody has to stick to the same style. [ Elements of Style ]. 

karelrobot      : a robot that works in 2D space. 
russian programmer: now that is what i call a hacker
kanye.rest      : an example of simple api. Quotes of Kanye West.
heroku          : hosts freely, you dynamic web app up to 5. 
git             : https://learngitbranching.js.org/
css-selectors   : too many selectors to cover=> w3schools
Mongodb on mac  : https://blog.londonappbrewery.com/how-to-download-install-mongodb-on-mac-2895ccd2b5c1
github/gitignore: templates for what formats should we include in the .gitigore for a particular project
plaintextoffend : a site to visit, where they post plain-text passwords.
haveibeenpwnd   : 
codesandbox     : online tool to write react apps, and even deploy
