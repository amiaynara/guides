Java
----------











1. Compilation and Execution
=============================

A code written in java is compiled by JavaC, which comes when we install JDK. This converts the code
into ByteCode. It can be observed, Main.class along with other classes will be created as separte
files. These files are platform independent. Why? Here another component comes into play, JRE[Java 
Runtime Environment]. It has a software component called- JVM (different for each platform: linux,
MacOs, windows). This converts these classes as native code, that is understood by the machine and
hence run.
Evidence:
        
        import com.package_name;
        public class Main{                              # Main can be replaced but then Refractor!
            public static void main(String[] args){     # main() is must
                System.out.println("Hello World");
            }
        }

        $javac Main.java            # converts the .java into .class
        $ls                         # will show you the Main.java & Main.class
        $cd ../..                   # move to the source folder in Intellij
        $java com.package_name.Main # Hello world ----- is printed. 

Note: unless specified the code snippets are present in side this Main class, in the text that follows. 
Important: It is important to place code blocks inside a function or a class.

Deployment
---------------------
The way to share the executable is by using JAR(Java ARchive) file. If we go and download Super
Mario Bros Java. Since we have been using JDK(which brought with it JRE and Javacompiler) therefore
we will be able to run this. JRE makes it happen. This will run on any platform(Windows, Mac, linux)
given we have java runtime on it.  This is what makes it platform independent. So if you download it
we will save it .jar file [Mario.jar]. Way to launch the file: 
        java -jar Mario.jar
        jar -tvf Mario.jar      // lists all the table of content of the .jar
        jar -xvf Mario.jar      // xtract verbose file 
Note that all java will be of the form .class which cannnot be run. Bur we might use the functionality.

So if we wanted to deploy our java code, we will have to make a .jar file out of our java code. We need to 
create 'manifest.mf' file inorder to create the .jar.
        Main-Class: ClientProgram

This manifest file will have the main-class, the entry point.
        
        jar -cvfm myProgram.jar manifest.mf *.class     // create verbose file with manifest file
to run the .jar file
        java -jar myProgram.jar         // can be shared ,, ... this is deployable,,, 
                        // given the user has the java runtime. of the given version

        java -tvf myProgram.jar         // to extract, you may get something more than expected.

Variables:
----------
    
    int age = 30;       # Declaring var , multiple can be declared in the same line
    int herAge=age;     # assigning one var to the other
    
Types:
Primitive    :

    Type        | Byte      | Range     
    byte          1           
    short         2
    int           4 
    long          8

    float         4                                 // above this only integers
    double        8
    char          2
    boolean       1

    int x=123_2123;  // is perfectly fine initialisation. but 123_ is not. 
    long a=1233_12312342;   // assumes the number to intger => java: integer number too large
    long a=1233_12312342l;  // is perfectly fine 'L' is alos good.

    float x= 12.99          // java: incompatible types: possible lossy conversion from double to float
    float x= 12.99F     // is ok

"" ---> is string in java unlike python
'' ---> is character in java


Reference types:
---------------
        Date now = new Date();
        sout(now);

The Memory management of these reference types is very different from the primitive ones. On creation,
a memory is allocated and the values are stored there. Name of the object is just a reference to that
memory location => stores the address of that oject. So when a new reference variable is created and 
assigned to an older reference variable, the new variable just starts 'pointing' to the oject memory
location, instead of creating a whole new object. So both start pointing at the same memory location.
So when the value of one of the references is changed the change is reflected in second as well. 
[is similar to python's list, python also follows a similar memry mangment].
    Also, note that the reference variable are created by user using 'new' and removed by JRE.

Remember: reference types are copied by the references and the primitive by value.

         Point p1=new Point(2,3);
         Point p2=p1;
         System.out.println(p2);
         p2.x=99;
         System.out.println(p1);        // [99,3] 


String
--------
java.lang       // automatically imported not need to import

        String s = new String("Hello world");
        String s = "Hello world";       // shorthand because of the often use.

        s=s+"hi";                       // concatenates

some useful methods:
--------------------
    .endswith("!!")
    .startswith("A")
    .length()
    .indexOf('e')           // returns index of 'e'
    .replace(target:"!", replacement:"*")       // original string does not change
                            // strings are immutable, we cannot change them.
    .toLowerCase()
    .toUpperCase()
    .trim()                 // gets rid of white spaces before and after. 
    .substring(1)           // gives all except the first ~ python's stringg[1:]
    .substring(3,5)         // ~python's stringg[3:5]=> excludes 5th INDEX
    .charAt(3)              // character at the third index [-1] does not work here. returns a 'char'
    .indexOf(char_or_string)// returns the index of first occurence
    .indexOf(ch_or_str,strt)// search starts from the index--> 'strt'

escape sequences: String name = "Hello \"Amiay\"";      // Hello "Amiay"
                  String location = "C:\\";             // one back slash to escape the other.
                  
\t, \n                are some other. 

Arrays
----------

They are also reference types. (or are they?) if not why are they declared using new.
        
        int[] arr = new int[5];
         System.out.println(arr);       //[I@5674cd4d      <-----some random value

         System.out.println(arr[0]);    //0  // this is true for any valid index
                                        //Index 6 out of bounds for length 5
This shows that are array are reference types and initialized with 0. We cannot exceed the index limit. 

So the desired result can be achieved using:

        import java.util.Arrays;

        ...

        int[] arr = new int[5];
        sout(Arrays.toString(arr));         // string representation of the array
                                            // this toString functiion is overloaded=> can be use for 
                                            // float as well

initialisation
        
        int[] arr={1,3,4,5};
        arr.length                          // not '.length()'
        Arrays.sort(arr)                    // sorts the actual array
        int[] arr2 = new int[] {1,8,9};     // is also a valid declaration
        sout(Arrays.toString(arr2));

        int[] int_arr = new int[5];         // arr of 0's
        String str_arr = new String[5]      // arr of nulls
        boolean bool_arr = new boolean[5]   // arr of falses
        // and so on

As usual we can also declare multi-dimensional arrays

        int[][]  mul = new int[2][3]        // note the two sq. braces.
        sout(Arrays.deepToString(mul));     // notice the use of '.deepToString'

        // initialisation
        int[][] aa = {{1,2},{3,4}}          // two dim array

final
=-=====
        
        final float PI = 3.14F                // 'F' necessary(default is 'double')

Upper case is used to define the constants. Final values cannot be changed. 

Arithmetics
============

        int x=5/3;                  // returns 1 
        int v=3/2;
         System.out.println(v);     //1
         double vv=3/2f;            // removal of 'f' will result in 1.0
         System.out.println(vv);    // 1.5

Adding a 'short' to an 'int':

// Implicit casting  // 
        int v=3/2;
        short x=2;
        //short c= v+x; // int cannot be converted to short
         int s=x+v;     //
         System.out.println(s);     // return 3

// two different primitives cannot be operated upon. 

short c=v+x; ===> java allocated a memory of '4 bytes' somewhere in memory, without any name. 
                This chunk is of integer type and then copies 1 into that location, and only now
                performs the addition with v(which is int).

    Note: Implicit casting occurs such that there is no data loss. 
            If it were to happen then, it will show error: lossy variable conversion.
            In that case we will have to carry out 'Explicit Type casting'.
            All the casting can happen when we have compatible classes. 
    String s="1";
    int x=(int)s + 1;  // explicit even won't work here
    int c=Integer.parseInt(s)+1; // this works 
    int xx=Integer.parseInt(dd)+3;      // this does not work incompatible types: double 
                                                cannot be converted to java.lang.String
Why such weird conversion?
Normally, the user the data that we get from users are in the form of strings. That is why these become
important.

We also have : 
        JDouble.parseDouble()

Math
=====
        
        int result=Math.round(1.1f);
        result = (int)Math.ceil(1.1f); // note the explicit typecasting
        result = (int)Math.floor(1.1f);
        result = Math.Random(); // Random number [0,1)
        result = Math.max(3,55);



Note: Abstract classes cannot be instantiated.
        NumberFormat number = new NumberFormat(); // java: java.text.NumberFormat is abstract; cannot be instantiated
        NumberFormat number = NumberFormat.getCurrencyInstance();  // Factory method.
        String res = currency.format(1234)
        String mon = n.format(1234);
         System.out.println(mon);       //  ₹ 1,234.00
         String indian_money = NumberFormat.getCurrencyInstance().format(7000);     // method chaining

Reading inputs, Scanning rather
---------------------------------
         import java.util.Scanner;
         ...

         Scanner sc  = new  Scanner(System.in);
         String name = sc.next(); // does not accept spaced input
         System.out.println(name);
         int age = sc.nextInt();    // .nextDouble(), .nextFloat(), nextByte()      But no .nextString()
         String lover = sc.nextLine();      // "Kate winslet" also acceptable.
         String pre_spaced = sc.nextLine().trim();
         
Control Flow
-------------

    if(condition){
        boolean block_scope = true;
    }

    sout(boolean);      // yields error as the 'block_scope' has scope only in side if block
                        // cannot find symbol
    // additionaly below is not valid
    if(condition)
    int x =33;          // declaration not allowed


            
    boolean isHighIncome;
    
    if(income>100_000){
        isHighIncome = true;
    }
    else {
        isHighIncome = false;
    }

    // **Pro-programmig**

    boolean isHighIncome = income > 100_000; 
    // **Pro-programming**

Ternary operator
------------------
    String className = income > 100_000 ? "First" :"Economy";

switch
----------

    String role = "admin";
    switch(role){
        case "admin":
            sout("you are an admin");
            break;
        case "moderator":
            sout("you are a moderator");
            break;
        default:
            sout("you are just a normal employee");  // if none of them cases are true.
    }

-------------------------------------------------------
    
    String s="hello";
    sout(s == "hello");         // prints true          // is not recommended --> reference tyepes

    // instead
    sout(input.equals("hello");     // is fine. 


for each loop
----------------

        String[] fruits = { "Apple" , "Mango", "Orange"};
        for(int i =0; i< fruits.length; i++){
            sout(fruits[i]);
        }

        // alternate and quite cleaner
        for(String fruit : fruits){
            sout(fruit);
        }


Methods
---------
Still working with the "Main" class, which already has 'main()' method which is necessary. 
We will add another method, self defined one. 

        public static void printJunk(){
            System.out.println("there is some junk in the trunk");
        }
Static is used because JVM will not create an object of the Main class, there fore to make 
the method attached to the class(rather than the object) we use the 'static' keyword. 'void'
means this will not return anything back to the calling method(which is 'main()' here). No 
parameter because we aren't passing any 'argument'.
       
        public class Main {

            public static void main(String[] args) {
            // write your code here
                MyUtils.sum2num(3,4);
            }
        }
        class MyUtils{          // default access modifier
            public static void sum2num(int a, int b){
                System.out.println(a+b);
            }
        } // declared in the same file. 

Above code works fine. However, 'public class MyUtils' will throw error, and can be resolved
by creating another file :
    java: class MyUtils is public, should be declared in a file named MyUtils.java

Note: MyUtils.java will not be Runnable as it does not have a main() method. 

Access Modifiers
-----------------

            type            private         public          protected       default
            ---------------------------------------------------------------------------
            class                           yes                             yes

            method          yes             yes             yes     

private: locally available, only available to the class


        public class Main {

            public static void main(String[] args) {
            // write your code here\
                c2.f2();
            }
        }

        class c1{
            public static void f1(){
                System.out.println("I am fucntion one");
            }
        }

        class c2{
            public static void f2(){
                System.out.println("I am function 2");
                c1.f1();
            }
        }

Importance of private
--------------------------

        public class Main {
            public static void main(String[] args) {
            // write your code here\
                c2.f2();    // this is fine
                c1.f1(); // <------------ error: private member cannot be accessed from out
                            // side of the class
            }
        }

        class c1{
            private static void f1(){
                System.out.println("I am fucntion one");
            }
            public static void ff1(){
                System.out.println("I impersonate f1");
                f1();       // within class so no need to use .operator
            }
        }

        class c2{
            public static void f2(){
                System.out.println("I am function 2");
                c1.ff1();
            }
        }


public:
    1.) with methods: makes accessible by any other class. [provided the enclosgin class is also public]
    2.) with class: Makes this class accessible anywhere in the project.=> we can instantiate this anywhere
                    in the project. However, to access its methods make sure you have the access modifier
                    of the methods set as 'public'(not private)
private:
    1.) with methods: makes the class visible only withins package. 

Note: when we are  calling classes from other packages, remember to 'import package_name'.


Object Oriented Programming
-----------------------------

        Class_name reference_var;
        reference_var = new Class_name();  // Class_name() ===> is the constructor for Class_name

The object comes alive only when the 'new' returns the reference.
Objects are runtime concept, and come into picture only during runtime. 


class Car{
    int hp; // instance variable
}


A variable provides us with named storage that our programs can manipulate. Java provides three types of variables.

Class variables − Class variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block. There would only be one copy of each class variable per class, regardless of how many objects are created from it.

Instance variables − Instance variables are declared in a class, but outside a method. When space is allocated for an object in the heap, a slot for each instance variable value is created. Instance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an object's state that must be present throughout the class.

Local variables − Local variables are declared in methods, constructors, or blocks. Local variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor, or block.


What is the point of OOP?
The is code organistion and providing logical structure to our code. In early days, for very small
functionalities it would have been fine, to follow just the procedural method as assisted by C.
But as the dependency, on the computers have increased exponentially, the code written on them 
should become more reliable. When these codes git really big, it becomes very hard to add new 
features and find bugs. But if we have implemented techniques such as
            - modularity
            - clean coding
            - oops
            - and so on.
things become more easier to maintain. And this pushes more progress.            



Inheritence
-----------

public class earth {
    public static void main(String[] args){
        animal ani = new animal("animal",3,34);
        ani.sleep();
        Fish f = new Fish("fish",2,5);
        f.swim(); // access modifier ='default' => available anywhere in the package.
        f.sleep();
    }
}
// animal in a different .java file
public class animal {
    String name;
    int age;
    int speed;

    public animal(String name, int age, int speed){ // default const. no more present
        this.name=name;
        this.age=age;
        this.speed=speed;
    }
    public void sleep(){
        System.out.println("I am sleeping");
    }
}
// Fish in a different .java file
public class Fish extends animal{

    public Fish(String name, int age, int speed){
        // Fish is animal, so it must be created the same way an animal is created.
        // default constructor overwritten
        super(name, age, speed);
    }
    public void swim(){
        System.out.println("Swimming...");
    }
}



Note: 'extends parent_class' is used to impose inheritence. This allows the child to inherit all the 
        PUBLIC methods of the parent class(here 'animal'). find out the exact access modifiers. 
     
      The parent cannot access the child's methods.

Interfaces
-----------
let us create another classes, 'bird' ,'sparrow' and 'chicken' to the above package. The chicken are 
also a birds and sparrows are bird too. So we can see that bird is the parent here.


        public class bird extends animal{
            public bird(String name, int age, int speed){
                super(name, age, speed);
            }
        }

        // another file
        public class Sparrow extends bird {
            public Sparrow(String name, int age, int speed){
                super(name, age, speed);
                // can Sparrow sleep---> yes it is an animal afterall
            }
        }

        // another class
        public class Chicken extends bird {
            public Chicken(String name, int age, int speed){
                super(name, age, speed);
            }
            public void fly(){
                System.out.println("Cannot fly...");    // fly() is being overwritten 
            }
        }

Over-ridding is one solution, when we don't want a particular method to be inherited by the child. 
This is one way. The other way is to use 'Interface', so you see how java provides us with an 
infrastructure, which helps us to better organise our code. That is how we have different, OOPs
each provide a different solution to a common solution to the problems that we face. Java has really
been able to do that.

    Interface is a Contract. Any class that wants to implement that 'interface' will have to 'implement'
all the 'abstract methods' that have been mentioned in that interface.
If in the above example, suppose, we have:
        // removing the 'fly()' method altogether from the 'bird' class
        public class sparrow extends animal implements Flyable{
            public sparrow(three args){
                super(three args);
            }

        // bird MUST  implement the abstract method fly()
        public void fly(){
            sout("flying...");
        }
        }

        // 'Flyable' class is must
        public interface Flyable {
            public void fly();
        }

There are many 'birds' that don't fly, therfore it is in our favour to define an interface 'Flyable',
which 'MUST' be implemented by the class that decides to use this 'Flyable' interface. Sparrow has to
implement this. However, classes like 'Chicken' need not bother about implementing fly(), it can simply
inherit the properties of the bird as usual, and since the bird class does not have 'fly()' method any-
more, chicken will have never 'heard' of flying!

NOTE: A class can 'extend' only and only "ONE" class. But a class can have many interfaces.

Abstract Classes
-------------------
You cannot create an instance of an Abstract class. Abstract methods cannot hava a body.

In the above example: 'animal' class can be made abstract. 
        
        public  abstract class  animal {
            String name;
            int age;
            int speed;

            public animal(String name, int age, int speed){ // default const. no more present
                this.name=name;
                this.age=age;
                this.speed=speed;
            }
            public void sleep(){
                System.out.println("I am sleeping");
            }

            // all animals can move but they do it differently
            public abstract void move();
        }

        public class bird extends animal{
            public bird(String name, int age, int speed){
                super(name, age, speed);
            }

            public void move() {
                System.out.println("Flapping wings...");
            }
        }
        public class Fish extends animal{

            public Fish(String name, int age, int speed){
                // Fish is animal, so it must be created the same way an animal is created.
                // default constructor overwritten
                super(name, age, speed);
            }
            public void move(){
                System.out.println("Swimming...");
            }
            public void swim(){
                System.out.println("I can swim...");
            }

            // Fish , being child of animal has to implement the move function
        }
        public class Chicken extends bird {
            public Chicken(String name, int age, int speed){
                super(name, age, speed);
            }
        }
        public class Sparrow extends bird implements Flyable {
            public Sparrow(String name, int age, int speed){
                super(name, age, speed);
            }
            public void fly(){
                System.out.println("Flying...");
            }
        }


        public class earth {
            public static void main(String[] args){
                animal sp = new Sparrow("bagada",3,21);
                sp.fly();       // this line causes error
                sp.move();
            }
        }

  java: cannot find symbol
  symbol:   method fly()
  location: variable sp of type animal   // <-------------- note the type is animal not Sparrow

replace 'animal' by 'Sparrow' in the creation of the object. An abstract class is a class that has abstract method.
Also the method 'has' to be implemented by the child class(the class that extends it). Another interesting:
we can make an 'animal' type to point at a Sparrow(present in the heap). [ Test whether this can be done
without making the parent class abstract].
    
    public class earth {
        public static void main(String[] args){
            animal sp= new Sparrow("..",3,21); 
            sp.fly(); // only move function can now be accessed using the 'sp' var of type animal
            sp.move();
        }
    }

Note that, you might think that making of animal class an abstract class does not help, as we have to
implement both the move method in both classes(bird and fish). but this provides with a dynamic approach.

public class earth {
    public static void main(String[] args){
        animal sp = new Sparrow("bagada",3,21);
        animal fis = new Fish("machli", 2,10);
        moveAnimal(sp);
        moveAnimal(fis);  // now we don't have to create two different methods 
                    // moveFish() and moveBird() 
    }
    public static void moveAnimal(animal anim){
        anim.move();
    }
}

AND THIS IS AN EXAMPLE OF POLYMORPHISM. WE HAVE USED THE 'IDEA' OF MOVING AND GENERALISED IT FOR 
MULTIPLE CLASSES INSTANCE TYPE. The moveAnimal method can work with all types of animals. 

public class earth {
    public static void main(String[] args){
        Flyable flyingBird = new Sparrow("mfug",3,33); // fine, bcs Sparrow implements Flyable
        Flyable flyingbb = new bird("birddd",3,33); // incompatible types: bird cannot be converted to Flyable
        flyingBird.fly();
    }
}

Only a class(Sparrow) that implements an interface(Flyable), can create objects(in heap) that can be
referenced by the interface class's reference variable(flyingBird, present in the stack).

File Handling
--------------
like System.out, we have System.in, you can look into the class description to know more. 

    import java.util.Scanner;
    File file = new File("myfile.txt"); // java.io
    Scanner input = new Scanner(file);

    while (input(.hasNextLine()){
        String line = input.nextLine();
        System.out.println(line);
    }

    input.close(); // this is also important. 

What happens if the file does not exist in the file location specified. 
Two ways:
        1. public static void main(String[] args)  throws FileNotFoundException {

        2. try{ input = new Scanner(file);}
            catch (FileNotFoundException e){
                e.printStackTrace();
            }
           
Method 1. 
---------
public class general_class {
    public int sub10fromArg(int number) throws Exception{
        // add condition to throw and exception
        if(number < 10){
            throw new Exception("Error message to be written here");
        }
        return number-10
    }
}

in main class-->
    general_class test_class = new general_class();
    try{
        test_class.sub10fromArg(9);
    }
    catch(Exception e){
        e.printStackTrace();
    }
this will display our error message when the exception condition is satisfied. 

Here the exception class was already implemented by java. But we can define our own 'exception' class.
We can do this by extending the 'Exception' class. and continue from there on. When we actually do 
implement our own exception we should to do it in another package. And the import that here we want to use. 
Look it up more when you need it.

File handling : a buffered file reader  
-----------------------------------------
This is an older way.

import java.io.*;

        public class Application {
            public static void main(String[] args) {
                File file = new File("my_file.txt");
                BufferedReader bufferedReader = null;
                FileReader fileReader = null;
                try{
                    fileReader = new FileReader(file);
                    bufferedReader = new BufferedReader(fileReader);

                    String line = bufferedReader.readLine();  // this might throw IOException
                                                        // we can see this in the class definition
                    while(line != null){
                        System.out.println(line);
                        line = bufferedReader.readLine();
                    }
                }
                catch(FileNotFoundException e)
                {
                    System.out.println("File not found!");
                } catch (IOException e) {
                    System.out.println("Can read the file"+file.getName());
                } finally {
                    // this will always run
                    try{
                        bufferedReader.close(); // will also throw IOException, from the definition
                    }
                    catch(IOException e){
                        System.out.println("Unable to close the file"+file.getName());
                    }
                }
            }
        }

Another thing to take care about is that, when the file name is wrong, the FileReader fil....  line 
will run and then code will crash and we will land into the catch block, note that we will have skipped
the part where the buffered reader was assigned something to point to. But now it is still pointig to
null, and we have skipped to bufferedReader.close() // note that we cannot call any method on null//.
That is why we get a 'NullPointerException', and this will be caught by catch block. 
    There should be a better way. The programmer does not have to catch a NullPointerException, becase
we know the thing is going to be null.  'finally' must close the RESOURCES----> this is very important.

In the above the finally should be replaced by

 finally {
            // this will always run
            try{
                //bufferedReader.close(); // will also throw IOException, from the definition
                if(bufferedReader != null){
                    bufferedReader.close();
                }
                if(bufferedReader != null){
                    fileReader.close();
                }
            }
            catch(IOException e){
                System.out.println("Unable to close the file"+file.getName());
            }
        }


Beyond java 1.7, we can use 'try with resource', which implements Autocloseable resource, so 
we don't need to close things manually. 

        import java.io.*;
        public class App_new_file_reading {
            public static void main(String[] args) {
                File file = new File("my_file.txt");
                // try with resource only after java 1.7
                // this gets rid of the finally block
                try(FileReader fileReader = new FileReader(file);
                    BufferedReader bufferedReader = new BufferedReader(fileReader);){


                    String line = bufferedReader.readLine();  // this might throw IOException
                    // we can see this in the class definition
                    while(line != null){
                        System.out.println(line);
                        line = bufferedReader.readLine();
                    }
                }
                catch(FileNotFoundException e)
                {
                    System.out.println("File not found!");
                } catch (IOException e) {
                    System.out.println("Can read the file"+file.getName());
                }
            }
        }

we can also use our own implementation of AutoCloseable : 
        
        class myClass implements AutoCloseable{
            @Override 
            public void close() throws Exception{
                sout("Closing");
            }
        }


Collections
-------------

int n = scanner.nextInt();
int[] arr = new int[n]; // you could create an array with a desired size, this size would be fixed. 

So we see how we can have restrictions, in terms of flexibility. We need some sort of support which
allows us to change the size of the array as and when needed. So this support is provided by the 
collections. 
    import java.util.ArrayList;
    ArrayList words = new ArrayList(); // is a dynamic array provided by java // it is Raw Type

    words.add("amiay");
    words.add("narayan");
    words.add("anything");
    words.add(9);

    words.get(0); // put the index here // this returns an object not a string
    String s = words.get(1) // will not compileible :Object cannot be converted to java.lang.String
    String s = (String) words.get(0) // 
    String s = (String) words.get(3) // will give error : type mismatch '9' cannot be converted to string
    Integer x = (int) words.get(3) // is fine.
    Object obj = (String) words.get(2); // also fixes the error but, now we loose the type 'int' or String
    
    x+y => error when we use objects. 
this forces the developer to always be aware of the data type that the a line is returning or working with.
This avoids any confusion programming, and leads to proactive programming. Type Safety. i

This was before Java 5. After that 
        Enter Generics

The problem was that ArrayList was letting in all the data types( strings, int, ...). What generics does
it allows only one type of data to be stored in an ArrayList. The Type of data is flexible, in the sense
that we can store any type of data, but we have to keep in mind that once we choose a type of data,
we have to store the same type of data for rest of the ArrayList. <type>

    ArrayList<String> words = new ArrayList<String>();      // Type safety.

    words.add("hello");
    words.add("narayan"); 
    words.add(3);               // gives compilation error. 
    words.add("3");             // is fine. 

ArrayList<type> one of many collection that java provides. LinkedList<int> is another. <int> is not valid
only <class> can be inserted into these <>. Only those types that are allowe inside the reference types, 
which are Reference types. 
        
    ArrayList<int> int_arr = new ArrayList<int>();      // is Invalid.

    ArrayList<Integer> int_arr = new ArrayList<Integer>();

ArrayList<type> is simply dynamic list. 
LinkedList<type> is simple a doubly linked list.   TYPE SAFE <= parameter.

Iterate over
------------
        
        ArrayList<String> animals = new ArrayList<String>();
        for(int i = 0; i< animals.size(); i++){
            System.out.println(animals.get(i));
        }

        // another way
        for(String value : animals){
            sout(value);
        } // this can also be used for other collections as well. 

ArrayList<referce_data_type_or_custom_class> list_name  = new ArrayList<........>(initial_capacity);

        ArrayList<Vehicle> vehicle_list = new ArrayList<Vehicle>(100);
        vehicle_list.add( new Vehicle(arg1, arg2......)) ; // we are creating object here. 
        vehicle_list.add( new Vehicle(arg1, arg2......)) ; // we are creating object here. 
        vehicle_list.add( new Vehicle(arg1, arg2......)) ; // we are creating object here. 
        vehicle_list.add( new Vehicle(arg1, arg2......)) ; // we are creating object here. 
        
        // to loop over these vehicles. 
        Vehicle temp_vehicle;
        for(Vehicle veh : vehicle_list){
            sout(veh.getPrice());       // Assuming our implementation of Vehicle has that method.  
        }
        // again we will have the @gibrish .. this is due to implementation of 'toString' in java.
        // so we will have to @Override in the Vehicle class the 'toString' function.

LinkedList<type> and ArrayList<type> both implement the interface <List>, so we can use <List> instead
of these two, this can come really handy we have both the kinds of lists and we want to pass both of 
them to a method, we can use List<type> as the parameter to the method. This will accept both ..
remember polymorphism. 
        LinkedList<type> ll = new .....
        ArrayList<type> arr = new .....
        operateOnBoth(ll);
        operateOnBoth(arr);

        ...

        public static void operateOnBoth(List<type> listt){
            // you can access the methods that are common to both ll or arr. 
        }
       // example of polymorphism



Set
-----

        HashSet<Integer> values = new HashSet<Integer>();
        values. add(33);
        values.add(320);
        values.add(33);
        System.out.println(values); // sout works here  [320, 33]  is the output. 

        <Integer> -------> <String>   , Ofcourse 

Unique values, Order does not matter. 

for ordered => LinkedHashSet<Integer> , but still not repeats. maintains insertion order. 

two objects of a class are not equal by default implementation of '.equals()', we have to override the
method '.equals()' in our class definition, to compare each of the properties one by one and only if
all the values are the same in both objects the values is assigned to as 'true'

        HashSet.get(0) is not valid, since it does not implement any order in the collection that it 
maintains. 

        HashSet<Animal> animals = new HashSet<Animal>();
        animals.add(new Animal("dog"));
        animals.add(new Animal("dog"));
        animals.add(new Animal("dinosaur"));
        animals.add(new Animal("cat"));
        animals.add(new Animal("dog"));
        for(Animal animal : animals){
            System.out.println(animal.name);
        }

        // does not eleminate the duplicates. Even if we change the definition of '.equals()'.
        This is because the duplicate are not removed using the '.equals()' method. It is done
using hashcodes. Each entry is assigned some hashcode, and only if the hash codes are the same
they both are treated as one.

                System.out.println((new Animal("amiay").hashCode())); // 2001049719

So to remove the duplicate in this case we have @Override the hashCode() method in our class definition.
Such that the hashcodes are same for both the objects. 

Some other useful methods:
--------------------------
        // list1 is a HashSet 
        list1.addAll(newList1);     // adds all the elements of newList1 to list1.
        list1.removeAll(newList1);  // removes all the elements that match in newList1 and list1.
        list1.clear;                // removes all the items
        list1.isEmpty();            // checks if the list is empty. 
        list1.retainAll(newList1);  // removes the non-intersecting values, from list1.


    List<Integer> li = new ArrayList<Integer>(list1);   // converts the HashSet---> list1 to list

    // now we can sort the li
    Collections.sort(li);

How does it handle strings? it sorts alphabetically, which is a natural order. 

But what to do when we have user defined objects. 
        
        HashSet<Employee> hashset = new HashSet<Employees>();

        hashset.add( new Employee(arg1, arg2,....);
        hashset.add( new Employee(arg1, arg2,....);
        hashset.add( new Employee(arg1, arg2,....);
        hashset.add( new Employee(arg1, arg2,....);
        hashset.add( new Employee(arg1, arg2,....);
        hashset.add( new Employee(arg1, arg2,....);

        ArrayList<Employee> myList = new ArrayList<Employee>(); // we created a list here
        Collections.sort(); // gives us an error

So, the .sort() method is implemented in the Collections class. And it does not know what is the 
order used to compare the employees( objects of the Employee class). We have to define that order.
Collections implements the 'Comparable' interface. We will also have to implement that interface. 
Now we have to implement ALL the methods declared in the Comparable interface. But luckily, we 
have only one method there in the  body of the interface. 
    
        public int compareTo(T o);

So, back in our class we will have implement (by overriding) the above method. 
        
        @Override
        public int compareTo(Employee o){
            if(this.salary < o.salary){
                return -1;
            }else if(this.salary > o.salary){
                return 1;
            }
        }

Note: sort() sorts in smallest to largest. 

HashMap, 
-----------------------------------------
        
        HashMap<String, String> dictionary = new HashMap<String, String>();
        dictionary.put("key", "value of the key")
        dictionary.put("key1", "value of the key")
        dictionary.put("key3", "value of the key")
        dictionary.put("key2", "value of the key")
        dictionary.put("key4", "value of the key")

        for(String word: dictionary.keySet()){  // note the use of .keySet()
            sout(word);
        }

        LinkedHashMap<String, String> ordered_dictionary = new ...  // preserves the insrtion order.

        // how to loop over both, the keys and the values 
        for(Map.Entry<String, String> entry : dictionary.entrySet()){
            sout( entry.getKey());
            sout( entry.getValue()); 
        } // look for implementation of '.entrySet()' in HashMap class definition

        Note : we cannot use duplicate keys

TreeMap
----------------










Java Generics
-----------------
Takes polymorphism to a whole new level. Same class definition can be used with diferrent types of data.

        Container<Integer, Double> cont = new Container<>(33, 23.3);
        Container<String, Double>  cont = new Container<>("amiay", 21.3); // provided our methods are good enough to handle.


    public class Container<it1, it2> {
        it1 item1;
        it2 item2;

        public Container(it1 item1, it2 item2){
            this.item1 = item1;
            this.item2 = item2;
        }
        // more method can follow similarly
    }


Similarly this can also be implemented for a method








































Wild Cards
------------
        Object obj  = new Object(); // Object is grand daddy of all objects in java
        MyClass myobj = new MyClass(); // Object can be replaced be any parent class of "MyClass"

        obj = myobj;  // is perfectly legal (Polymorphism)

        // but this is not true with generic class. 
        ArrayList<Object> emp = new ArrayList<>();
        ArrayList<MyClass> my_class_obj = new ArrayList<>();
        
        emp = my_class_obj;             // is not legal

        // wild cards can be used here. 

        ArrayList<?> emp2 = new Array<>(); 
        ArrayList<String> accountant2 = new ArrayList<>();
        em2 = accountant2;      // is now legal

        //also
        ArrayList<? extends Employee> employeee3 = new ArrayList<>(); // <> defines here the Upper Bound
                // the highest type that can go here is 'Employee' and ofcourse its children
        ArrayList<Accountant> accountant3 = new ArrayList<>(); // <String> is not legal
        // <Object> here is not legal , since it is parent of all. 

        // we can also set the lower bound
        ArrayList<? super Employee> emp3 = new ArrayList<>(); // super <----- sets the lower bound
                                // all the parent can be used to point that 'emp3'
        ArrayList<Object> super_daddy = new ArrayList<>(); // is legal
        ArrayList<Accountant> acc4 = new ArrayList<>();     // is NOT legal 
        























Multithreading
---------------
One of comptetive advantage of java since the begining was its multithreading ability. 
when we normally run our program, we have only one thread running, the 'main()' thread. but 
we can start running multiple threads when we have use the .start() method and use the class
object of Thread(or our class that extends Thread class).

        package com.java_basics_package;

        public class Main {

            public static void main(String[] args) {
            // write your code here
                Task taskRunner = new Task();
                taskRunner.start();
                System.out.println("I am amiay");

            }
        }

        class Task extends Thread {         // Thread implements Runnable
            public void run(){              // Task cannot implement; it can only extend 
            // if it tries to implement and just run .run() method it will just cause single 
            // thread to run. multi threading has to start with .start()
                for(int i=0; i< 100; i++){
                    System.out.println(i);
                }
            }
        }
        // I am amiay ===== is printed before the 0 1 ... 99

Remember, it is never legal to start a thread more than once. This will cause error. It may not be
started once it has completed execution. adding 'taskRunner.start()' once more would cause error.
if you want to do that, create one more instance of the Task class and run that again.

... 
    Task taskRunner = new Task();
    taskRunner.start();
    Task taskRunner2 = new Task();
    taskRunner2.start(); // starting another thread. 
    // you will see 0's and 1's and .... printed randomly, like two threads were intertwinded. 
    // this is because of the cpu giving and regaining the core, using some scheduling algo.
...

        System.out.println(i+Thread.currentThread().getName());
        // can be used to get the Thread-0 or Thread-1.. and so on convention is used.
        System.out.println(i+Thread.currentThread().setName());
        // can be used to set the name 

However, there is another way:
    psvm(){
        Task taskRunner = new Task();
        Thread t1 = new Thread(taskRunner);
        t1.start();
    }
    class Task implements Runnable{
        public void run(){ // implementing the abstract method run() from Runnable
            // for loop to print the values from 0 to 99
        }
    }

Yet another method is by using the anonymous classes within the Thread() constructor in the above
code. And we have to IMPLEMENT the run() method there. 

Syncronisation
---------------
The non-synchornous behaviour is due to the cpu-sharing by the threads. This is very likely to cause
inconsistent results. This because of the lack of control over cpu, or OS rather. We are not able to
tell the thread when to leave the thread, the OS does it and it is done randomly, or using some 
scheme. To make this process of acquiring and reliquishing the cpu, we have to make the process atom-
ic. This can be done, in Java, using the synchronized(this){ ........}, block.
    
    public class Sequence {
        private int getNext(){
        synchronized(this){     <------------------- 
            value = value +1;
            return value;       
            }                   <-------------------
        }
    }

or 
    public class synchronized Sequence{.............}

This is one way to make sure the Thread Safety.

Threads and Lists
------------------
Concurrent collections. They are all synchronised.
Vectors(they are old) were thread safe.

But ArrayList<> is not thread safe. Simulatneous reading and writing of such a list is not supported.
.join() or .sleep() are primitive ways to handle. 


Producer Consumer pattern
----------------------------



























jshell
-------
    /type
    /drop method method_name
    /edit
    /help           // opens up the help 
    /exit
    /history
    /list
    $ jshell -c name_of_jar_file.jar  // note .jar files are deployable version of our code(JRE runs it)




Functional programming
------------------------
Behaviours do not exist outside of a class. In Java 8, introduced the concept of Functional Programming. 
Here functions can exist without being wrapped inside a classs. It provides flexibitlity. Before that 
we had something called anonymous classes(something close to functional programming).

        public class App {
            public static void main(String[] args) {
                Human tom = new Human();
                walker(tom);
                Robot walle = new Robot();
                walker(walle);  //<------------------------
            }

            public static void walker(Human human){
                human.walk();
            }
        }
The marked line will cause an error because the walker method cannot be called on Robot object walle.
This to work:
        1. Make A parent class "Walkers" and make Human and Robot extend them
        2. Make an interface "Walkable" and make both Human and Robot implement them. 

Going with the second:
        public class Human implements Walkable{......}
        public class Robot implements Walkable{......}
        public interface Walkable{....} 
        
        public static void walker(Walkable walkingEntity){}// method expects a Walkable object

We are good as long as we pass the right class object into the method. 
so we could have an anonymous class defined in the main method. 

                walker(new Walkable(){

                    @Override
                    public void walk() {
                        System.out.println("Custom object walking...");
                    }
                }); // we created the object on the fly

Using lambda to achieve the above:
        
        walker( () -> System.out.println("Custom object walking..."));  // looks similar to arrow functions
                                                                        // in javascript
why did above work?
walker accepts only a Walkable interface(look at the param). And by using the above lambda expression actually we are
actually implementing that method present in the Walkable interface. That is why it is able to run.
If we add more methods to Walkable interface, it no more remains a 'functional interface' and we will 
get error. 
                                                                            
        walker( () -> {System.out.println("Custom object walking...");
                            });

What is a functional interface?
An interface with just one abstract method. 
        public interface ALambdaInterface {
            public void someMethod();
        }

        ALambdaInterface aBlockOfCode = () -> {
            sout();
            sout();
        }; // RHS is lambda expression


        walker(ALambdaInterface); // will give error because of the type of Walkable is not same 
                    // as ALambdaInterface (although both are 'functional interface')

        // so instead we use 
        Walkable aBlockOfCode = () -> {
            sout();
            sout();
        }; // RHS is lambda expression

        walker(aBlockofCode); // Now this works just fine

