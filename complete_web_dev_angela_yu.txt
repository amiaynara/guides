CSS
----
<link rel="stylesheet" src="" href="location/of/file/relative.css">

Note that threre is a distinction between 'src' and 'href', where 'src' just embeds the code 
from other place to the current location, while 'href' does not cause waiting of the loading
of the whole page. This is the reasion styles can be put in the head, but <script> are not. 
'href' specifies the location of the 'resource', like the location of the stylesheet.

- Note that inline has higher precidence the internal or external css,code. Hence be careful
while searching for a bug. external<internal<inline.

Css selectors:
--------------
tag_name < classes < id's

one element can have only one id. while one element can have multiples classes. 
Id's have higher precedence over classes. 
Id's have to be unique.     

Pseudo-classes. 
---------------
Html elements have states. after certain action and before it. e.g., :hover, 
img:hover{
    color: gold; // will change the color to gold each time the 'img' is 'hovered'.
}

Making my own website
---------------------
favicons : are the icons that appears at the top of the page in the besides the title. 


Box model:
-----------
The box model of css. Everything is regarded as a box. And the height and width can be manipualted
as required. This can be done either using a 'px' or '%'. to acquire the specified dimension the 
element will force oother elements out the way as well. 
Important: The border is NOT included in the dimension of the element. By default it is 3px on each
side. So adding a border will lead to requirement of some extra space around the actual box. 
    
A box will automatically fit the content, by resizing it if it falls short. Therefore the content 
might appear very close to the edge of the box. So we can add something called padding. These
PADDINGS will further increase the dimension of the box, if it is required. We can think of padding
as space within the box and the content. 

Margin: is the buffer space "OUTSIDE" the box. This will not increase the size of the box.  
It gives spaces between two boxes. 

blocking and inline elements
------------------------------
The blocking elements create, by default, a box that occupies the whole width of the viewport(parent).
While the inline elements ALLOW next element to be right next to them. 
Disadvantage of using inline elements : Their width cannot be changed. They occupy the content's width.
While <div>'s can easily be changed by width or height. Note that this will still NOT ALLOW the next
element to sit next to it. It still occupies the whole of the line. 
Four choices:
    - display:
            - inline   // like <span>, can't change the width
            - block     // width can be changed, but no next element allowed in the same line
            - inline-block // multiple elements allowed + changeable width
            - none          // Takes the element out of the flow of the page.  
Note: 'visibility' is another css property that allows us to hide an element on the page. But HERE
      the space for the element is present , just the element is not visible. 

Note: Although the width of BLOCK element is always the viewport width, the Height is the content
        width. 

      Order comes from the content of the order of content in the html file. 

      Children sit on top of parent by default. <div><h1>HI</h1></div> => HI will be displayed 
      over div [ not behind it]. 
These were the default behaviour, and expected these can be altered using the 'position' in css.
        
        - static        // default, normal flow as per above 3 rules. 
        - relative      // position relative to the default value 
            - left
            - right
            - top
            - bottom
                    Note: It does not affect the position of anything else, even in case of 
                            collision. 
                            It does not take the element out of the flow of the document. 
        - absolute
                    Note: It TAKES the element out of the flow of the document=> others AFFECTED.
                          This is done wrt the parent element. 
            
        - fixed  // remains fixed irrespective of scrolling. 

centering
---------
text-align: center;     // it has to provided in the parent element, of the element which contains 
                        // a bunch of elements which we want to align to center. 
                        // div : contains lot of items
                        // that div is in body => body{ text-align:center}
margin: 0 auto;         // applied to the desired block element.

Font Families
-------------
    - serif
    - sans-serif
    - monospace
    - cursive
    - fantasy
Each of the above font families are available with font types such as Arial, Times New Roman and so on.
fall back font family is put after the intended font families. 
    font-family: "Helvetica Neue", Arial, sans-serif; /* means that if none is available, what ever
                                                       sans-serif is installed will be used.*/
however, if we want to ensure the exactness of rendering of fonts. The obvious solution is to 
use web, as a source of delivery. And Google-Fonts come to rescue. They are commercially free. 
Type faces. 

Dynamic font sizes: By default font appear at 16px, if we use exact values[like 90px], then even if the
    user changes the size to be large, the selected text will remain 90px, because have used absolute 
    height. However, if we want to change height of the fonts as the page is scaled, then we will have
    to use ---> % or em. 1em = width of 'M', convention in action. In modern days: 1em=16px.  
zooming in is different though, zooming will scale irrespectively. 

consider following piece of css:
                    
                    body{
                        font-size: 2em; // could be in percent 
                    }
                    h1{
                        font-size: 3.5em; // could be in percent // 'em' is inherited.
                    }
        Note: the size of h1 will turn out to be 7em, i.e. 7*16px, 112px !
So to avoid this, we have 'rem' in css3. This 'root em' does not do unwanted scaling. 

float: Use it only when you want to wrap the text around the some another div. Sounds similar to 
'inline-block', 'block'... and position: relative.  However, this has to be used very carefully.
Avoid using 'float'  all over the page. Instead try to use 'relative', 'absolute', 'fixed'..


With that now we move on to bootstrap
--------------------------------------
front end libraray... makes it easy to design the front end of our website. Twitter. github. 
After downloading the bootstrap files, you will have whole lot of .css files. Among them is 
bootstrap.css. This class is the key to link the previous concepts to whatever bootstrap does. 
Previously we wrote our own styles.css and accessed it using the <link rel="stylesheet" href="">
This time around we have files that already has 'humongous' number of lines of css codes. That 
has a lot of classes defined within it. And these classes are meant for style particular elements.
For example <button> in plain vanilla html would invoke a button which is quite 'boring'. But 
If we look into the  bootstrap.css file. We will find that there are lot of classes that add 
properties to the button classes. And we can choose from these predefined classes and modify 
our 'boring' looking button into something really good looking. 

It also cuts down the time to desing, 'cause we already have built in classes on the bootstrap off-
icial site as well. However, one must note that this add some bit of complexity to the front end 
part. as we have lot ( and I mean a lot!) of classes that we down know about, and cannot know about, 
even if we wanted to. This might make the webiste files overall, look bloated and heavier than it 
actually should be. 

Instead of downloading the bootstrap files individually to our each website project, we can just 
use the service provided by CDN[content delivery network ]. CDNs have multiple copies of our sites
present at various location on the globe. And it makes the delivery process of the contents of the 
site more efficient. 
Another thing that bootstrap exploits is its popularity. A vast majoriy of the sites use bootstrap, 
so the moment we access a website that uses bootstrap, the smart browswers cache the bootstrap classes
and other required items. And next time we go to another website that uses bootstrap, these classes
need not be downloaded again, this makes the rendering of the website very fast. 

Note: to exploit the caching it has to 'mass-recognisable' using your own dowloaded version does not 
        help. 

WireFraming and Mockups:
-----------------------
WireFraming is a quick process to start the processing of designing. Just the blueprint. 
Mockups are like the final products' screenshot. 

wireframes ==> layout ==> mockups ==> prototypes. 

transform: rotate(45deg); // rotates the element box by 45 deg clockwise. 


Media queries: Using Native CSS=> Making pages Responsive.
----------------------------------------------------------
                
                @media <type> <feature> { ... }

                @media screen (min-width: 900px){ ... }
                @media print { h1{ color: red} }  // while printing on a paper change color-> red. 

                @media (min-width: 900px) {
                    h1{
                        color: red;
                }
                } // if the minimum width of the screen(media) is 900 or greater than 900px. 
                  // Change the color of h1 to red. 
                
                @media (min-width: 900px) and (max-width: 1000px) {
                    h1 {
                        color: green;
                    }
                }
ViewPort is NOT the same as the device screen size. 

CSS selectors:
--------------
            selector1, selector2 {
                background-color: red;
            }   /* selects both selector1 and selector2 and applies the css property.

            selector1 .class_name tag_name {
                font-family: "Montserrat", sans-serif;
            }  /* is used to select tag_name inside of '.class_name' which is inside selector1
    combined Selectors:
            .class#id2 {
                color: red;
            }       /* Note that there id no space between the selectors. 

Before combining selectors, just think that whether this combination will bring a logical
structure and more readability. If the answer is YES, sure go ahead. 

Principles of webdesign
-----------------------
        - Color theory
        - User Interface Design
        - Typography
        - User Experience Design

Color theory:
-------------
red: tells energy, biology, attraction
green: fresh, good.
Yellow: difficult to avoid, color of sun. 
Blue: trust, reliability
Purple: Royality, feminine [pink]

In the color wheel we can combine the colors : adjacent to each other, opposite to each other
a triangle or a perfect square. 

Typography:
-----------
Serif: they have little feet. Inspired from the marble carving. Makes your design look old.
        Provides authority. Legitimacy. 
        - Old Style : Least prominent difference in width fo feet to pillers. 
        - Transitional: lesser difference. 
        - Modern : Most visible. 

Sans-serif: Simple, Sensible, Straightfoward, Approachable.

Manage User attention:
---------------------
        - Making the important part standout. 
        - Layout : wikipedia => not good. 
        - Alignment : Reduce the number of lines of alignment. 
        - White Space : Adding whitespace can make you appear expensive. 
        - Audience :  feel free to break upper rules to fit the audience. 

User Experience
---------------
        - F-Layout
        - Z-Layout
        - With greater power comes greater responsibility. 
            

Bootstrap4:
-----------

.container : They are by default responsive. And it is convenient to have it as a parent.
             By def. has some margin on both sides. 
.container-fluid : Occupies total width of the viewport. This also responsvie.
.btn btn-primary : 


carousel
--------
Tip: First create the content of the caraousels for each slide style them using appropriate
    classes and properties. Then move ahead and put them in the carousel template.  

Buttons [ arrows ] are described using the <span> tags previous and next. 


Code Refactoring
----------------
It is of utmost importance that we write code that are more readable and easy to maintain. 
        - Readability
        - Modularity
        - Efficiency
        - Length 
Maintance does not always have to do with the very very high efficienct code. The code should be
efficient enough, meanwhile is should be more readable so that a person reading it a year later
[ that could be yourself ] can easily understand what is going on. As Angela suggets think of that
person as a murderer. It truly can help you save a lot time and brush upon some skill very very 
quickly. 
Also try to Keep the code DRY. 


JavaScript
-----------------------
Built in 10 days, to make the browsers more dynamic. Has its origin in NetScape, Mozilla. 
They were standardized as ECMA Scripts. ES6 is a version. Initially, built just for toying,  now
it has become the most popular language, because of its simplicity and availability. C++ and Java, 
were regarded as more serious language due to their closeness to the hardware and being compiled. 
JS is interpreted language and it line wise read by the engine. 

typeof()
alert()  // only strings can be printed, so use '+' to concatenate.
console.log() // use ',' to separate. you can use '+' here but, this will convert number to string.
word.length
string.slice(start_index,end_index+1)   // like in python. "test_string".slice(x,y) works just fine.
string.toUpperCase() // returns a string with upper case // the current string remains as such.
string.toLowerCase()
x++, --x    // are all the same as previous c++ // this is not valid in python though.
Math.round(number)
Math.ceil()
Math.floor()
Math.random() // generates a random number [0,1)
===     // exactly same
==      // does not care about the data type. [coersion]
&& AND
|| OR
!  NOT
arr.includes()  // returns true or false based on the presence or absence of the element in the array. 
arr.push(element) // similar to python's append() ==> adds to the end of the list. 
arr.pop;        // no paren, unlike python. 







collections
------------
var arr=[];
 



There is place in google chrome : snippets where we can create our own script and run Ctrl+Enter.
Hard reload and clear cache can be done using the refresh button on google chrome.

Concatenation
--------------
var a="amiay";
var b="naraya";
var name=a+" " + b;

'+' will convert numbers to string.


So we saw how we can use inline CSS code to modify the style of the content on our page. 
        style="background-color: red"

Similarly we have, inline javascript code. 
        onload="alert('hello');"

similarly we have <style> and <script> as internal css and javascript respectively. 

        <script src="index.js" type="text/javascript">  <!-- for external js--> 

DOM
---
Document Object Model

    var heading=document.lastElementChild.firstElementChild;
    heading.innerHTML="Changed_Heading";
This will change the content of the page on the fly. While rendering the element of a page, the
browser converts these elements in the form of a tree. And elements have parent-child relation
among them. However, using plain vanilla JavaScript we can manipulate the content, style and beha-
viour of our page. 
This can be done by selecting the particular element, and then modifying the css ... 
Also, selection can be done in a number of ways. 
So each element on the page is described using an Object, for example, body is an object, a button
is also an object. And so on and on. Hence the Name : D Object M. 
So Being an Object these will also have 
            - Properties : color, background-color, height...
            - Methods : which can change the properties and all sort of other action can be done. 
Example :
<button>
    Properties: innerHTML, style, firstChild
    Methods: click(), appendChild(), setAttribute()

document.getElementsByTagName("h1")         // this will ALWAYS return an array            
document.getElementsByClassName("h1")       // this will ALWAYS return an array
document.getElementById("id_name") // note that this will return single object
document.querySelector("h1 #id_name")       // similar to CSS selector. // RETURNS ONLY FIRST.
document.querySelectorAlL("#list li")[1]    // array hence using indices. 
.getAttribute("href")
.setAttrubute("href", "src")                // sets the attribute to the second string. 

Note: 'font-size' becomes fontSize in JavaScript. Camel-Casing in action. 

<button class="btn">Click here</button>

document.querySelector("button").classList; // returns a list of class associated with "button".
document.querySelector("buttton").classList.add("amiay")   // will add class
So, the new html will be:
        <button class="btn amiay">Click here</button>

We could also change color, height, and all sorts of things using ONLY JavaScript. But this is not
what JavaScript is meant for; ofcourse we will encounter cases where it only befitting to use 
JavaScript to change the CSS style of the element, but normally for general styling we will always
use styles.css.

one use could be to toggle between hiding and showing elemnet. 


styles.css:
        .invisible{
            display: none; // visibility: none;
        }

document.querySelector("button").classList.add("invisible");
The above JS code will make the button go 'invisible'. and we can type following to make it visible:

document.querySelector("button").classList.remove("invisible");
document.querySelector("button").classList.toggle("invisible");

innerHTML vs textContent
------------------------
<h1><p>This is a para</p></h1>
document.querySelector("h1").innerHTML =====> <p> ... </p>
document.querySelector("h1").textContent =====> "This is a para"


Note: while changing the value of the element, make sure to use "", because it is not JS. 


----------------------
Backend
==----================
Any modern day web app consists of three layers: 
    1. Front end : this is the interface to the user. 
    2. server end : This processes the data and serves the user
    3. database : This stores the data 

There are serveral technologies to choose from: 
Java(       ),  nodejs(express), ruby( on rails), php(      ), python and so on. \
Here we will choose Nodejs( and companies like , Netflix, uber also use node and more are joining. )

Recall, that we JavaScript was originally meant to be run only on the client side. Only the javascript 
engines could convert these into a machine code. various browsers had different engines. V8, by google
turned out to be the fastest => popular. But still it was only meant for the browser and making a site
more interactive. Node takes it to a next level. This is a runtime environment that allows javascript
to be used on the server side as well. Javascript, can therefore, be used to create a full fledged
desktop applications! Js can now be run independently.
"A platform on Chrome's javaScript runtime for
easily building fast and scalable network applications. Nodejs usees and event-driven, non-blocking I/O 
that makes it lightweight and perfect for data-intensive and real-time applications that run across 
distributed devices". 

Node allows us to use the hardware directly, for example it can access the file system directly. Other-
wise java script would have been locked on the browsers only.

We can compare Nodejs with JRE(java runtime environment) and V8 being equivalent to Java Virtual Machine(
which is responsible to execute the bytecode that is generated after compilation by javacompiler).

        Push main() onto the call stack.
        Push console.log() onto the call stack. This then runs right away and gets popped.
        Push setTimeout(2000) onto the stack. setTimeout(2000) is a Node API. When we call it, we register the event-callback pair. The event will wait 2000 milliseconds, then callback is the function.
        After registering it in the APIs, setTimeout(2000) gets popped from the call stack.
        Now the second setTimeout(0) gets registered in the same way. We now have two Node APIs waiting to execute.
        After waiting for 0 seconds, setTimeout(0) gets moved to the callback queue, and the same thing happens with setTimeout(2000).
        In the callback queue, the functions wait for the call stack to be empty, because only one statement can execute a time. This is taken care of by the event loop.
        The last console.log() runs, and the main() gets popped from the call stack.
        The event loop sees that the call stack is empty and the callback queue is not empty. So it moves the callbacks (in a first-in-first-out order) to the call stack for execution.

How does a runtime environment work?
An application that’s currently running interacts with the runtime environment via a runtime system. The runtime environment in turn acts as a go-between between the application and the operating system. As soon as a program is executed, it sends instructions to the computer’s processor and RAM, and accesses system resources. The runtime environment thus includes hardware, memory, variables in the environment, and interactions with the user and software components.

A runtime environment provides various basic functions for memory, networks, and hardware. These functions are carried out by the runtime environment instead of the application and work independently of the operating system. They include reading and writing files, managing input and output devices, searching and sorting files, and transporting data via networks.

 Note
The individual modules of a runtime environment are saved in runtime libraries. In Windows, you can identify these libraries based on the extension .dll (dynamic link library); in Linux they have the file suffix .so (shared object).

-------------------------------------------
Node has to be installed on the system before we start to work on it. 
Getting started
---------------------------------------------
        mkdir intro-to-node
        cd intro-to-node
        touch index.js // typically we linked this file to our index.html, so that V8 engine of the browser
                        // could execute it. But here we don't. This will now be handled by Nodejs
                        // Now we have the power to run it on the command line itself. 
        cat >> index.js
        console.log("Hi there")
        node index.js   // prints "Hi there" on the screen.
Native Node Modules:
These are the libraries that come bundled with Node(built by the Node team), that help us attain
various things such as accessing the local file system. To be able to use the modules we need to 
incorporate it into our project=> "Require"
    
        const fs = require("fs"); // includes the module
        fs.copyFileSync("file1.txt", "file2.txt")       
        // Above copies the content of one file to another file.
        // Note that this type of operation allows us to use javascript like python, java or C++.

Native Node modules are already comes along with the download. With the download also comes the 
npm, node package manager. This is very very very famous as it is the largest number of modules
there. These modules are not "Native", they are external. These are written by other developers. 

        var super_villains = require("supervillains");
        var name = super_villains.random();        
        console.log(name);
        

        node index.js       // will throw an error, as this is External module, and we have to
                            // npm to install, for that we have to do an -> 
                            // npm init
                            // npm install supervillains --save
                            // npm index.js         // spits a name. 
One more thing we can notice is that: this external module is now a dependency. Therefore, 
this will be added to the package.json, which was created when we did 'npm init'.

Express
---------
Remember javascript had jquery, which made our life a lot easier. Similarly here we have 
express for Node. Express is a framework, which helps in developing web applications. It
does so by reducing the repetition, if we were to write the web app with only Node out of
the box. It is obvious that express is an external modules => we will have to install it
using npm. 
        npm install expres --save       // --save is default
        // this will also create 'node-modules' directory.

// inside server.js
        const express = require("express");
        const app = express();  // a function that represents the express module
        app.listen(3000);       // this server will listen to requests on port 3000
                                // it listens to http request at port 3000. 
// on running this server 'node server.js' // the command lines 'hangs', it waits for a request
on the specified port. 

when we open 'localhost:3000', on the web-browser, there is an error
but now if we start the above server on the terminal, Cannot GET /
This is because our server does not know how to a 'GET' request. It is ofcourse listening now on 
port 3000, but does not know how to respond.
        // add the following
        app.get("/", function(request, response){
            console.log(response);
        });
This will still cause Cannot GET / , but now we can see a whole lot of info on the terminal where 
the server is running. 
            // change the call back
            response.send("hi there"); // error will be gone and we see the message on the browser
                    or 
            response.send("<h1>Hi there</h1>");// we can also send html

anatomy of get request
-----------------------
.get(route, callback){
    response
    }
we can have different requests made at different routes, and we might want send different responses
for each of these routes. Here the concept of routes comes handy. 

Note: starting and restarting the server each time we make a change becomes a pain in the ass.
'nodemon' to the resque. 
        npm install -g nodemon      // I already had this. // like liteserver and npm start 


We can also send file as a response to requests. 
        res.sendFile(__dirname + "index.html")      // sends an html file as a response

post 
----
suppose we wanted to do some calculation on the server side. (say addint 2 numbers). In that case
we need to be able to post some data to the server. These can be collected using a form. 
        <form action = "/" method = "post">
            <input type = "text"> 
            ...
        </form>

This will not work we have app.post() method implemented on our server.js.[404 not found] or cannot Post /
so we need to implement that. 
        app.post("/", function(req, res){
            res.send("thanks for posting");
        });

Only now the post-request is successful(Note that server has performed on the data yet). 
    post request is the form data. and the response is : " thanks for posting"
Now we have to be able to use that data on the server so that we can carryout our logic on the data
obtained. And return something meaningful. 

For this purpose we use 'body-parser'. 
        .urlencoded()
        .json()
        .text()     // are some of the modes provided by the parser. 

include the line below to use the parsed form of data posted.
        app.use(bodyParser.urlencoded({extended:true}));
        app.post("/",function(req, res){console.log(req.body)});

        // on the server terminal 
        { num1: '3', num2: '4', Calculator: 'Calculate' }


APIs
----
Application Programming Interfaces
An application programming interface (API) is a computing interface that defines interactions between multiple software intermediaries. It defines the kinds of calls or requests that can be made, how to make them, the data formats that should be used, the conventions to follow, etc.APIs let your product or service communicate with other products and services without having to know how they're implemented. This can simplify app development, saving time and money.

        1. Endpoints: https://api.kanye.rest/        : is an example of endpoint, a GET request is made
        2. Paths :   narrow down your search of data 
        3. Parameters: This also helps https://sv443.net/jokeapi/v2/joke/Any?contains=hello
                this allows more flexibility, as everything can not be thought before hand and put
                in as a route. https://sv443.net/jokeapi/v2/joke/hello, may be it does not exist and 
                will throw an error. To get rid of that we can provdie parameters using '?'. Multiple
                parameters are chained using '&'.
                Parameters are nothing but key-value pairs.
        4. Authentication: 
http://api.openweathermap.org/data/2.5/weather?q=London&appid=52884f523158675d8a622ffe4bc73f03&units=metric
is an example of api call and we get the following response: 
{"coord":{"lon":-0.13,"lat":51.51},"weather":[{"id":802,"main":"Clouds","description":"scattered clouds","icon":"03n"}],"base":"stations","main":{"temp":10.61,"feels_like":7.23,"temp_min":10,"temp_max":11.11,"pressure":1020,"humidity":88},"visibility":10000,"wind":{"speed":4.41,"deg":193},"clouds":{"all":43},"dt":1606199770,"sys":{"type":3,"id":2019646,"country":"GB","sunrise":1606203250,"sunset":1606233651},"timezone":0,"id":2643743,"name":"London","cod":200}

Note: The order of query does not matter. 
also, it is very difficult to type and work with chrome directly to make requests. So we use Postman. 

The data that we received is in the format of JSON. [ Advantage of using api over webpages is that, we 
get faster parsing and the business logic can be abstracted]. Note the below:
        var javascript_object = {
            name : "amiay",
            roll : 11640140
        }
However in json, the keys are also strings.
The weather app
----------------
we create app.js, when a get request is made to this server(app.js), it should in turn make another api
call to 'open weather' server and fetch the JSON data. And then app.js should 'respond' with that data. 
Till now we know that we can respond with a string message or html file :
        res.send("Hi this is the response to get request");
        res.sendFile(__dirname + "/index.html"); // sends a file

We want to make a request to open weather server, this could have been done with the help of 'request' 
module(external module). But as of 2020, this has been deprecated. 
Therefore, other ways are :
        1. https : native standard library of node
        2. axios : external module
        3. got
        4. superagent : external module

we will use the native module- https. to incorporate add 
        const https = require("https");
        app.get(........){
            https.get(api_url, function(res){
                console.log(res);
            });     // this will log the response to the app terminal
        }
The response will have a lot of information. We have to now parse that information to be able to get 
the information that is required. 

To get the statusCode of the response we can: 
                console.log(res.statusCode);
                // 200 -> OK
                // 404 -> resource not found. 

To get the data, in the format we want. we can use:
        res.on("data", function(data){
            console.log(data); // logs incoming data from open weather as Hexadecimal\
            const weather_data = JSON.parse(data);
            console.log(weather_data);  // logs the pretty form of data on to the terminal 
        }); 
        // if the response has any data, then the above function will log the data on the app.js terminal
Note:
----
We can also reverse the above step. JSON -> String 
    var object  = {
        name : "amiay", 
        color : "red",
        iq : "high"
    }
    var flat_object = JSON.stringify(object); // packs into a single string
===========================================================================
            const descript = weather_data.weather[0].description;
            console.log(descript); 
Note: 
we can res.send() only once for a particular app.get() request. Therefore to send multiple data
we have to use, res.write() each time and finally send the data using res.send().

                const weatherIcon = weather_data.weather[0].icon;
  1             var icon_url = "http://openweathermap.org/img/wn/"+weatherIcon+"@2x.png";
  2             console.log(icon_url);
  3             response.write("<img src ="+icon_url+">");
  4             response.send();

http://openweathermap.org/img/wn/01d@2x.png <----- is the generated url.

Below is the whole code to implement it roughly

        1   const express = require("express");
          1 const https = require("https");     // does not require npm install, as 'https' is native module
          2 const bodyParser = require("body-parser");
          3 const app = express();
          4 app.use(bodyParser.urlencoded({extended:true}));
          5
          6 app.get("/", function(req, response){
          7     // we want to make an request to open weather server using its api
          8
          9     response.sendFile(__dirname + "/index.html");
         10     });
         11 app.post("/", function(req, res){
         12     const query = req.body.city;
         13     const appid = "52884f523158675d8a622ffe4bc73f03";
         14     const units = "metric";
         15     const url = "https://api.openweathermap.org/data/2.5/weather?q="+query+"&appid="+appid+"&units="+units;
         16     https.get(url, function(response){
         17         response.on("data", function(data){
         18             const weatherData = JSON.parse(data);
         19             const temp = weatherData.main.temp;
         20             const icon = weatherData.weather[0].icon;
         21             const description = weatherData.weather[0].description;
         22             const icon_url = "http://openweathermap.org/img/wn/" + icon + "@2x.png";
         23             res.write("<h1>The temperate of "+query+ " is: "+temp+"</h1>");
         24             res.write("<p>"+description+"</p>");
         25             res.write("<img src="+icon_url+">");
         26             res.send();
         27         });
         28     });
         29
         30 });


+=======================================================================================================

Newsletter project
-------------------
We use a template from bootstrap. Also, note that bootstrap will be delivered using cdn. This page
also makes use of a custom stylesheet. This has to be linked. But when you set up your app.js.
you send this file(form that we created using bootstrap) :
    app.get("/", function(req, res){res.send(__dirname+ "/signup.html")});
This will however not be able to make use of static resources such as the custom stylesheet and the
local images. For that we will have to include the following line:
        app.use(express.static("public")); // here public is the folder that is static

set up the mail chimp account. And get the api key (you don't want any strange person to change the 
list of subscribers). To manage the audience you also will have to get the unique id for audience. 
https://us7.admin.mailchimp.com/lists/settings?id=514628    <- is the link to get it. 

The detailed implementaion can be seen at ~/learn/Udemy/angel..../news-letter-project/

Basically we are using our server to listen at port 3000, 
        - first when a get request is made at "/", our server returns the signup.html
        - then when a post request is made from the form present here( at signup.html), the servers
            resolves that can stores the info(firstName, lastName, emailId). 
        - now the server makes use of https.request(url,option, funtiont(response){})     to talk to
            the mailchimp api. This step requires you to be precise, as protocols are strict and 
            cannot be surpassed. 
        - the response of this api is 200 if everything was alright.
        - Overall, it is very good exercise to get used to requests(post, get) and get familiar with
            apis.
But till now we have only been able to list to port 3000 on the localhost. But how do we make this 
available on the world wide web. We can indeed make our own servers and endure the pain of managing it
and do the labour that is essentially required to keep it maintained up and running. 

So we rent servers: Heroku comes to help here. 
        sudo snap install heroku --classic      # installs heroku cli
        heroku login                            # will sign you in
        # requires  node, git and npm
Create a git repository of your app
Create a Procfile, with 'web: node app.js'
        git init
        git add .
        git commit -m 'some comment'
        heroku create       # green blue means => everything ok
        git push heroku master
        heroku ps:scale web=1   # to ensure atleast one instance of your app is running
        heroku open             # to open your app in default browser
                                # Basically this will make get request on the app.js
                                # So the app will respond with home route, which in our app
                                # is the sign up page, we can carry on after that
Make sure that you have changed the port setting as well, there is no guarentee that port 3000 will 
be free, on the heroku server it has been deployed. 
        3000 ------> process.env.PORT || 3000

       heroku logs --tail      # be sure to check the logs, both in case of failure and success.


Templating
------------
Probelm : we can use the res.send() only once within a app.get(). So what to do when we have multiple
lines of html or other data to send. We can use res.write() each time and then send everything at the
end. But this also is very repetitive. Solution: we can send files using res.sendFile(). However, this
can also, sometimes, becomes tedious. Just for sending small data we have to write a whole lot of html
code.       ---------- The solution to this Templating ------------------
    
The software that we are going to use for templating is EJS.
        npm install ejs --save
        app.use("view engine", "ejs");      // declares that 'ejs' will be used as view engine
        mkdir views
        touch views/index.ejs
        // edit this 'index.ejs' file as follows 
        <html.... boiler plate

            <%= kindOfDay %>        // this will be the variable that will change its value
                                // according to the data that is sent over as a response

        </html>

        var weekday ---> has the value that will be sent to the list.ejs.

also the res.send() will now be changed to :   res.render("list", {kindOfDay: weekday});
'list.ejs' is the name of the template file, that we want to give some value to. This will 
complete the page. 
ejs also allows to run code on the html template itself. For example if the value that was
passed to the template is >6 then change the background of the page. Or could be any other
control flow requriment, that is easy to do on the html page itself. However, don't try to
stuff too much on the template. Limited is fine. 
Note: For every line of javascript you will have to add     <%  java...script %>
Like the following : 
  1             <%if(kindOfDay === "Saturday" || kindOfDay === "Sunday"){   %>
  2             <h1 style="color:purple">It is a <%= kindOfDay %></h1>
  3             <%}else{ %>
  4             <h1 style="color:blue">It not is a <%= kindOfDay %></h1>
  5             <% } %>

<% ----> is called 'scriptlet' tag. there are other tags as well. Check the docs of EJS.

Note: Formatting dates.
----------------------
        var today - new Date();
        var options = {
            weekday : "long", 
            day: "numeric",
            month: "long"
        }
        var day = today.toLocaleDateString("en-US", options); // this will check with operating system
        res.render{
            kindOfDay: day
        }


Now how can we pass data from the template to the server? 
This can be done with the help of post request.
        app.post("/", function(req, res){
            items.push(req.body.doItem);    // items was an array
            res.redirect("/");              // redirects to post at "/"
        }
Note: If there are two variables, one that changes value in app.get and the other changes the value in 
app.post(). There is a problem. One type of response will be sent at one time. So the other variable will
be left empty. This will create problem in res.render(), So to overcome this we will always have to send 
all the data(missing) everytime we want to render that .ejs template. This should be handled using scope
of variables and proper initialisations. 

When a form is submitted. We can look at all the data that is posted:
    console.log(req.body)       // { next_item: 'code', list: 'Work' } // second related to button
                                //    name: entered_value     name:value
So, we can use name:value to dynamically assign <%varialbe%> to 'value'. This will help us uniquely
identify the post request. 

ejs - LAYOUTS
-----------------
small changes can be handled easily, accross multiple webpages, using 'scriptlets'. But this 
is not a great way to generalise for webpages that changes drastically, however some data are
consistently same throughout, like header or footer. 
here layouts come to resque. 
        <%- include("header") -%>
        ...
            some content specific to this page. 

        ...
       <%- include("footer") -%>













Some useful websites
----------------------
colorhunt       : lets you choose hex code of nice colors 
flaticon        : lets search for icons... a huge collection
giphy.com       : animated gifs
codeply.com     : write code for bootstrap.
ui-patterns     : choose UI patterns according to your needs. 
dribble         : designer have put forward their port-folios. 
sneakpeekit     : printout and start 'wireframing'
balsamiq        : industry standard
bootsnip.com    : snippets of various useful template (pricing, navigation), to get inspiration from. 
mobilefriendtest: tests how mobile friendly your site is. 
adobecolorpalet : Lets you play around with colors and select color combination 
canva.com       : online graphic editing program. Something you can quickly build and SHOWCASE. 
idiomatic.js    : Living doc. => everybody has to stick to the same style. [ Elements of Style ]. 

karelrobot      : a robot that works in 2D space. 
russian programmer: now that is what i call a hacker
kanye.rest      : an example of simple api. Quotes of Kanye West.
heroku          : hosts freely, you dynamic web app up to 5. 
git             : https://learngitbranching.js.org/
css-selectors   : too many selectors to cover=> w3schools
